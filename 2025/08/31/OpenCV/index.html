<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#2d3748">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#2d3748">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lizhulan.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":true,"color":"#667eea","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="OpenCV常用API基本操作读取 cv2.imread()  显示cv2.imshow()  保存 cv2.imwrite()   shape(高度，宽度，通道) 灰度化将三通道彩色图像转换成单通道灰度图image_gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) 直接读取成单通道的灰度图image_gray2 &#x3D; cv2.imread(&#39;.&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV">
<meta property="og:url" content="https://lizhulan.github.io/2025/08/31/OpenCV/index.html">
<meta property="og:site_name" content="李猪兰">
<meta property="og:description" content="OpenCV常用API基本操作读取 cv2.imread()  显示cv2.imshow()  保存 cv2.imwrite()   shape(高度，宽度，通道) 灰度化将三通道彩色图像转换成单通道灰度图image_gray &#x3D; cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) 直接读取成单通道的灰度图image_gray2 &#x3D; cv2.imread(&#39;.&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://free.picui.cn/free/2025/08/31/68b42a996b462.png">
<meta property="og:image" content="https://free.picui.cn/free/2025/08/31/68b42b645cb12.png">
<meta property="og:image" content="https://free.picui.cn/free/2025/08/31/68b424d9af3a3.png">
<meta property="article:published_time" content="2025-08-31T11:13:33.000Z">
<meta property="article:modified_time" content="2025-08-31T11:13:33.065Z">
<meta property="article:author" content="李猪兰">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://free.picui.cn/free/2025/08/31/68b42a996b462.png">

<link rel="canonical" href="https://lizhulan.github.io/2025/08/31/OpenCV/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>OpenCV | 李猪兰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">李猪兰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-docs">

    <a href="/docs/" rel="section"><i class="fa fa-book fa-fw"></i>docs</a>

  </li>
        <li class="menu-item menu-item-plugins">

    <a href="/plugins/" rel="section"><i class="fa fa-plug fa-fw"></i>plugins</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/lizhulan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lizhulan.github.io/2025/08/31/OpenCV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="李猪兰">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李猪兰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OpenCV
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-31 19:13:33" itemprop="dateCreated datePublished" datetime="2025-08-31T19:13:33+08:00">2025-08-31</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>读取 <code>cv2.imread()</code> </p>
<p>显示<code>cv2.imshow()</code> </p>
<p>保存 <code>cv2.imwrite()</code> </p>
<p> <em>shape(高度，宽度，通道)</em></p>
<h3 id="灰度化"><a href="#灰度化" class="headerlink" title="灰度化"></a>灰度化</h3><p>将三通道彩色图像转换成单通道灰度图<br><code>image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</code></p>
<p>直接读取成单通道的灰度图<br><code>image_gray2 = cv2.imread(&#39;./img/lena.png&#39;, cv2.IMREAD_GRAYSCALE)</code></p>
<h3 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h3><h4 id="cv2-threshold—全局二值化"><a href="#cv2-threshold—全局二值化" class="headerlink" title="cv2.threshold—全局二值化"></a>cv2.threshold—全局二值化</h4><p><code>retval, dst = cv2.threshold(src, thresh, maxval, type)</code></p>
<blockquote>
<p><strong>参数说明</strong></p>
<ul>
<li>src:输入图像，必须是单通道灰度图像（8-bit 或 32-bit 浮点型）。</li>
<li>thresh:阈值，用于将像素值分类。</li>
<li>maxval:当像素值超过阈值时赋予的新值（在二值化中通常为 255）。</li>
<li>type:阈值化类型，决定如何应用阈值。常用的类型包括：</li>
</ul>
<p>cv2.THRESH_BINARY: 二值化，大于阈值的像素设为 maxval，否则设为 0。</p>
<p>cv2.THRESH_BINARY_INV: 反二值化，大于阈值的像素设为 0，否则设为 maxval。</p>
<p>cv2.THRESH_TRUNC: 截断，大于阈值的像素设为阈值，其余保持不变。</p>
<p>cv2.THRESH_TOZERO: 零化，大于阈值的像素保持不变，其余设为 0。</p>
<p>cv2.THRESH_TOZERO_INV: 反零化，大于阈值的像素设为 0，其余保持不变。</p>
<p>cv2.THRESH_OTSU: 自动计算阈值（适用于双峰直方图图像），需与 cv2.THRESH_BINARY 或 cv2.THRESH_BINARY_INV 结合使用。</p>
<p>cv2.THRESH_TRIANGLE: 使用三角法自动计算阈值，适用于单峰直方图图像。</p>
<p><strong>返回值</strong></p>
<ol>
<li><strong>retval</strong>:<ul>
<li>实际使用的阈值。如果使用 cv2.THRESH_OTSU 或 cv2.THRESH_TRIANGLE，返回的是自动计算的阈值。</li>
</ul>
</li>
<li><strong>dst</strong>:<ul>
<li>输出图像，与输入图像大小和类型相同。</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>OTSU阈值法</strong></p>
<blockquote>
<p>注意：OTSU在使用时候，需要配合其他的二值化方法去进行，其模式就是 <strong>cv2.THRESH_OTSU + 要二值化的方法的参数</strong><br>使用OTSU，thresh参数没有任何用处<br>其中，<strong>ret</strong>存放的是二值化所用的阈值，如果我们使用固定阈值法时，<strong>ret</strong>没有任何作用<br>当我们使用<strong>OTSU</strong>去计算最合适的阈值时，<strong>ret</strong>就有用了<br>image_thresh里存放的是二值化的图(本质上是与image_gray大小相同的单通道数组)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 导入OpenCV的库</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"># 1. 读取要滤波的图像</span><br><span class="line">image = cv2.imread(&#x27;./img/lena.png&#x27;)</span><br><span class="line">image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line"># 定义阈值法所需要的阈值</span><br><span class="line">thresh = 150</span><br><span class="line"># 定义阈值法所需要的最大值</span><br><span class="line">maxval = 255</span><br><span class="line"># 使用opencv的函数去进行二值化</span><br><span class="line">ret, image_thresh = cv2.threshold(image_gray, thresh, maxval, cv2.THRESH_BINARY + cv2.THRESH_OTSU)</span><br><span class="line">print(ret)</span><br><span class="line"># 3. 图像显示</span><br><span class="line">cv2.imshow(&#x27;image&#x27;, image)</span><br><span class="line">cv2.imshow(&#x27;image_gray&#x27;, image_gray)</span><br><span class="line">cv2.imshow(&#x27;image_thresh&#x27;, image_thresh)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>

<h4 id="图像自适应二值化—局部二值化"><a href="#图像自适应二值化—局部二值化" class="headerlink" title="图像自适应二值化—局部二值化"></a>图像自适应二值化—局部二值化</h4><p>dst &#x3D; cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C)</p>
<blockquote>
<p><strong>参数说明</strong></p>
<ol>
<li><strong>src</strong>:</li>
</ol>
<ul>
<li>输入图像，必须是单通道灰度图像（8-bit）。</li>
</ul>
<ol start="2">
<li><strong>maxValue</strong>:</li>
</ol>
<ul>
<li>当像素值满足条件时赋予的新值（通常为 255）。</li>
</ul>
<ol start="3">
<li><strong>adaptiveMethod</strong>:</li>
</ol>
<ul>
<li>自适应阈值计算方法，可选以下两种：</li>
<li><code>cv2.ADAPTIVE_THRESH_MEAN_C</code>: 使用局部区域的均值作为阈值。</li>
<li><code>cv2.ADAPTIVE_THRESH_GAUSSIAN_C</code>: 使用局部区域的加权均值（高斯加权）作为阈值。</li>
</ul>
<ol start="4">
<li><strong>thresholdType</strong>:</li>
</ol>
<ul>
<li>阈值化类型，只能是以下两种：</li>
<li><code>cv2.THRESH_BINARY</code>: 大于阈值的像素设为 maxValue，否则设为 0。</li>
<li><code>cv2.THRESH_BINARY_INV</code>: 大于阈值的像素设为 0，否则设为 maxValue。</li>
</ul>
<ol start="5">
<li><strong>blockSize</strong>:</li>
</ol>
<ul>
<li>局部区域的大小（必须是奇数），用于计算阈值。核的大小，通常为奇数 3，3， 5，5</li>
</ul>
<ol start="6">
<li><strong>C</strong>:</li>
</ol>
<ul>
<li>从计算出的阈值中减去的常数，用于微调阈值。通常是正数，但也有可能是0或负数</li>
</ul>
<p><strong>返回值</strong></p>
<ul>
<li><strong>dst</strong>:</li>
<li>输出图像，与输入图像大小和类型相同。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image_binary = cv2.adaptiveThreshold(image_gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 7, 5)</span><br></pre></td></tr></table></figure>
<h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p><code>cv2.VideoCapture()</code> 读取视频或摄像头。根据设备编号获取，一般摄像头都是0。可以传入视频的路径。<br><code>cap.read()</code>读取摄像头的每一帧<br><code>cap.release()</code>释放<br><code>cv2.VideoWriter()</code> 保存视频。</p>
<h4 id="读取摄像头"><a href="#读取摄像头" class="headerlink" title="读取摄像头"></a><strong>读取摄像头</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 创建窗口</span><br><span class="line">cv2.namedWindow(&#x27;video&#x27;, cv2.WINDOW_AUTOSIZE)</span><br><span class="line">cv2.resizeWindow(&#x27;video&#x27;, 800, 600)</span><br><span class="line"></span><br><span class="line"># 打开摄像头</span><br><span class="line">cap = cv2.VideoCapture(0)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # 从摄像头读取视频帧, ret布尔值表示帧是否被正确读取，frame是读取的视频帧</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    # 将视频帧在窗口中显示</span><br><span class="line">    cv2.imshow(&#x27;video&#x27;, frame)</span><br><span class="line">    # 等待键盘事件，如果q，退出</span><br><span class="line">    key = cv2.waitKey(1)</span><br><span class="line">    if key == ord(&#x27;q&#x27;):</span><br><span class="line">        break</span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h4 id="读取视频"><a href="#读取视频" class="headerlink" title="读取视频"></a><strong>读取视频</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 创建窗口</span><br><span class="line">cv2.namedWindow(&#x27;video&#x27;, cv2.WINDOW_AUTOSIZE)</span><br><span class="line">cap = cv2.VideoCapture(&#x27;img/deepseek.mp4&#x27;)</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # 读取视频帧, ret布尔值表示帧是否被正确读取，frame是读取的视频帧</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    # 将视频帧在窗口中显示</span><br><span class="line">    cv2.imshow(&#x27;video&#x27;, frame)</span><br><span class="line">    # 等待键盘事件，如果q，退出</span><br><span class="line">    key = cv2.waitKey(50)</span><br><span class="line">    if key == ord(&#x27;q&#x27;):</span><br><span class="line">        break</span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h4 id="摄像头录视频"><a href="#摄像头录视频" class="headerlink" title="摄像头录视频"></a><strong>摄像头录视频</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 创建窗口，会自动设置大小</span><br><span class="line"># cv2.namedWindow(&#x27;video&#x27;, cv2.WINDOW_AUTOSIZE)</span><br><span class="line"># 可以调整窗口大小</span><br><span class="line">cv2.namedWindow(&#x27;video&#x27;, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.resizeWindow(&#x27;video&#x27;, 800, 600)</span><br><span class="line"># 打开摄像头</span><br><span class="line">cap = cv2.VideoCapture(0)</span><br><span class="line"></span><br><span class="line"># 获取摄像头的分辨率</span><br><span class="line">frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">fps = int(cap.get(cv2.CAP_PROP_FPS))</span><br><span class="line"># 创建多媒体文件</span><br><span class="line"># cv2.VideoWriter_fourcc函数用于指定视频文件的编解码器,指定Motion JPEG（MJPG）作为视频的编解码器</span><br><span class="line">video_fourcc = cv2.VideoWriter_fourcc(*&#x27;mp4v&#x27;)</span><br><span class="line"># 参数：输出文件的名称、视频的编解码器、帧率以及视频的尺寸（宽度和高度）一般是摄像头真实采样分辨率。</span><br><span class="line">vw = cv2.VideoWriter(&#x27;./img/myvideo1.mp4&#x27;, video_fourcc, fps, (frame_width, frame_height))</span><br><span class="line">while True:</span><br><span class="line">    # 从摄像头读取视频帧, ret布尔值表示帧是否被正确读取，frame是读取的视频帧</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    if not ret:</span><br><span class="line">        break</span><br><span class="line">    # 将视频帧在窗口中显示</span><br><span class="line">    cv2.imshow(&#x27;video&#x27;, frame)</span><br><span class="line">    # 写数据到多媒体文件</span><br><span class="line">    vw.write(frame)</span><br><span class="line">    # 等待键盘事件，如果q，退出</span><br><span class="line">    key = cv2.waitKey(50)</span><br><span class="line">    if key == ord(&#x27;q&#x27;):</span><br><span class="line">        break</span><br><span class="line">cap.release()</span><br><span class="line">vw.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><h4 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a><strong>绘制直线</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.line(image, pt1, pt2, color, thickness, lineType)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：<br>image：要绘制直线的图像。<br>pt1：直线的起点坐标，格式为 (x1, y1)。<br>pt2：直线的终点坐标，格式为 (x2, y2)。<br>color：直线的颜色，格式为 (B, G, R)。<br>thickness：直线的粗细（默认值为 1）。<br>lineType：线型（默认值为 cv2.LINE_8）。</p>
</blockquote>
<h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a><strong>绘制文本</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.putText(image, text, org, fontFace, fontScale, color, thickness, lineType)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：<br>image：要绘制文本的图像。<br>text：要绘制的文本内容。<br>org：文本的左下角坐标，格式为 (x, y)。<br>fontFace：字体类型（如 cv2.FONT_HERSHEY_SIMPLEX）。<br>fontScale：字体缩放比例。<br>color：文本颜色，格式为 (B, G, R)。<br>thickness：文本的粗细（默认值为 1）。<br>lineType：线型（默认值为 cv2.LINE_8）。</p>
</blockquote>
<h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a><strong>绘制矩形</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.rectangle(image, pt1, pt2, color, thickness, lineType)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：<br>image：要绘制矩形的图像。<br>pt1：矩形的左上角坐标，格式为 (x1, y1)。<br>pt2：矩形的右下角坐标，格式为 (x2, y2)。<br>color：矩形的颜色，格式为 (B, G, R)。<br>thickness：矩形的边框粗细（如果为 -1，则表示填充矩形）。<br>lineType：线型（默认值为 cv2.LINE_8）。</p>
</blockquote>
<h4 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a><strong>绘制圆形</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.circle(image, center, radius, color, thickness=1, lineType=LINE_8, shift=None）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明<br>image: 输入图像，圆形将绘制在此图像上。<br>center: 圆心的坐标，格式为 (x, y)。<br>radius: 圆的半径（以像素为单位）。<br>color: 圆的颜色，格式为 (B, G, R)。例如，(0, 255, 0) 表示绿色。<br>thickness (可选): 圆的线宽。如果为负数（例如 -1），则填充圆形内部。默认为 1。<br>lineType (可选): 线条类型，默认为 cv2.LINE_8。其他选项包括 cv2.LINE_4 和 cv2.LINE_AA（抗锯齿）。<br>shift (可选): 圆心坐标和半径的小数位数。通常不需要设置。</p>
</blockquote>
<h3 id="图像形态学变换"><a href="#图像形态学变换" class="headerlink" title="图像形态学变换"></a>图像形态学变换</h3><h4 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a><strong>卷积核</strong></h4><p>cv2.getStructuringElement 是 OpenCV 中用于创建形态学操作所需的结构元素（Structuring Element）的函数。结构元素是一个小的形状（如矩形、圆形、十字形等），用于定义形态学操作（如腐蚀、膨胀、开运算、闭运算等）的邻域范围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.getStructuringElement(shape, ksize, anchor)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明<br>1.	shape: 	结构元素的形状，可以是以下常量之一： 		<br>cv2.MORPH_RECT: 矩形结构元素。 		<br>cv2.MORPH_ELLIPSE: 椭圆形结构元素。 		<br>cv2.MORPH_CROSS: 十字形结构元素。<br>2.	ksize: 	结构元素的大小，格式为 (宽度, 高度)。例如，(3, 3) 表示一个 3x3 的结构元素。<br>3.	anchor（可选）: 	结构元素的锚点位置，默认为中心点 (-1, -1)。 	</p>
<p> 返回值 	返回一个指定形状和大小的结构元素（NumPy 数组）。</p>
</blockquote>
<h4 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h4><p>腐蚀操作就是使用核在原图（二值化图）上进行从左到右、从上到下的滑动（也就是从图像的左上角开始，滑动到图像的右下角）。在滑动过程中，令核值为1的区域与被核覆盖的对应区域进行相乘，得到其最小值，该最小值就是卷积核覆盖区域的中心像素点的新像素值，接着继续滑动。由于操作图像为二值图，所以不是黑就是白，这就意味着，在被核值为1覆盖的区域内，只要有黑色（像素值为0），那么该区域的中心像素点必定为黑色（0）。这样做的结果就是会将二值化图像中的白色部分尽可能的压缩，如下图所示，该图经过腐蚀之后，“变瘦”了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.erode(src, kernel, anchor=(-1, -1), iterations=1, borderType= BORDER_CONSTANT, borderValue=0)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明<br>1.	src: 	输入图像，可以是灰度图像或二值图像（通常为 uint8 类型）。<br>2.	kernel: 	结构元素（Structuring Element），用于定义腐蚀操作的邻域范围。 	可以通过 cv2.getStructuringElement 创建。<br>3.	anchor（可选）: 	结构元素的锚点位置，默认为中心点 (-1, -1)。<br>4.	iterations（可选）: 	腐蚀操作的迭代次数，默认为 1。<br>5.	borderType（可选）: 	边界填充类型，默认为 cv2.BORDER_CONSTANT。<br>6.	borderValue（可选）: 	边界填充值，默认为 0。</p>
<p>返回值 	返回腐蚀后的图像</p>
</blockquote>
<h4 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h4><p>膨胀与腐蚀刚好相反，膨胀操作就是使用核在原图（二值化图）上进行从左到右、从上到下的滑动（也就是从图像的左上角开始，滑动到图像的右下角），在滑动过程中，令核值为1的区域与被核覆盖的对应区域进行相乘，得到其最大值，该最大值就是核覆盖区域的中心像素点的新像素值，接着继续滑动。由于操作图像为二值图，所以不是黑就是白，这就意味着，在卷积核覆盖的区域内，只要有白色（像素值为255），那么该区域的中心像素点必定为白色（255）。这样做的结果就是会将二值化图像中的白色部分尽可能的扩张，如下图所示，该图经过腐蚀之后，“变胖”了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.dilate(src, kernel, anchor=(-1, -1), iterations=1, borderType= BORDER_CONSTANT, borderValue=0)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明<br>1.	src: o	输入图像，可以是灰度图像或二值图像（通常为 uint8 类型）。<br>2.	kernel: o	结构元素（Structuring Element），用于定义膨胀操作的邻域范围。 o	可以通过 cv2.getStructuringElement 创建。<br>3.	anchor（可选）: 	结构元素的锚点位置，默认为中心点 (-1, -1)。<br>4.	iterations（可选）: 	膨胀操作的迭代次数，默认为 1。<br>5.	borderType（可选）: 	边界填充类型，默认为 cv2.BORDER_CONSTANT。<br>6.	borderValue（可选）: 	边界填充值，默认为 0。 </p>
<p>返回值 	返回膨胀后的图像。</p>
</blockquote>
<h4 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h4><p>开运算（Opening Operation） 是形态学图像处理中的一种基本操作，它是**腐蚀（Erosion）和膨胀（Dilation）**的组合。开运算先对图像进行腐蚀操作，然后再对腐蚀结果进行膨胀操作。开运算的主要作用是去除小物体、平滑物体边界，同时保留物体的主要形状。<br>开运算的作用<br>1.	去除小物体：<br>	开运算可以去除比结构元素小的物体或噪声。<br>2.	平滑物体边界：<br>	开运算可以使物体的边界变得更加平滑。<br>3.	分离物体：<br>	如果两个物体之间有细小的连接，开运算可以将它们分离。<br>4.	保留主要形状：<br>	开运算不会显著改变物体的主要形状。</p>
<p>cv2.morphologyEx 是 OpenCV 中用于形态学操作的函数，支持多种形态学操作，包括开运算、闭运算、形态学梯度、顶帽运算和黑帽运算等。它的功能比单独的腐蚀（cv2.erode）和膨胀（cv2.dilate）更强大，可以一次性完成复杂的形态学操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.morphologyEx(src, op, kernel, anchor=(-1, -1), iterations=1, borderType=BORDER_CONSTANT, borderValue=0)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明<br>1.	src: o	输入图像，可以是灰度图像或二值图像（通常为 uint8 类型）。<br>2.	op: o	形态学操作类型，可以是以下常量之一： 	cv2.MORPH_OPEN: 开运算（先腐蚀后膨胀），用于去除小物体、平滑边界。 	cv2.MORPH_CLOSE:<br>闭运算（先膨胀后腐蚀），用于填补空洞、连接断裂部分。 	cv2.MORPH_GRADIENT:<br>形态学梯度（膨胀结果减去腐蚀结果），用于提取物体边缘。 	cv2.MORPH_TOPHAT:<br>顶帽运算（原图像减去开运算结果），用于提取比结构元素小的亮区域。 	cv2.MORPH_BLACKHAT:<br>黑帽运算（闭运算结果减去原图像），用于提取比结构元素小的暗区域。<br>3.	kernel: o	结构元素（Structuring Element），用于定义形态学操作的邻域范围。 o	可以通过 cv2.getStructuringElement 创建。<br>4.	anchor（可选）: o	结构元素的锚点位置，默认为中心点 (-1, -1)。<br>5.	iterations（可选）: o	形态学操作的迭代次数，默认为 1。<br>6.	borderType（可选）: o	边界填充类型，默认为 cv2.BORDER_CONSTANT。<br>7.	borderValue（可选）: o	边界填充值，默认为 0。 返回值 •	返回形态学操作后的图像。</p>
</blockquote>
<h4 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h4><p>先膨胀后腐蚀<br>开运算 vs 闭运算</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>开运算 (cv2.MORPH_OPEN)</th>
<th>闭运算 (cv2.MORPH_CLOSE)</th>
</tr>
</thead>
<tbody><tr>
<td>操作顺序</td>
<td>先腐蚀后膨胀</td>
<td>先膨胀后腐蚀</td>
</tr>
<tr>
<td>主要作用</td>
<td>去除小物体、平滑边界</td>
<td>填补空洞、连接断裂部分</td>
</tr>
<tr>
<td>适用场景</td>
<td>去除噪声、分离物体</td>
<td>填补空洞、连接物体</td>
</tr>
<tr>
<td>对物体形状的影响</td>
<td>保留主要形状</td>
<td>保留主要形状</td>
</tr>
</tbody></table>
<h4 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h4><p>形态学梯度是数学形态学（Mathematical Morphology） 的核心运算之一，核心逻辑是对图像先后执行 “膨胀” 与 “腐蚀” 操作，再通过两者的像素级差值，提取目标物体的边缘轮廓。该方法广泛应用于计算机视觉、图像分割、目标检测等领域，本质是利用膨胀扩大目标区域、腐蚀缩小目标区域的特性，使两者差异对应目标与背景的过渡边界（即边缘）。<br>**形态学梯度 &#x3D; 膨胀（I）− 腐蚀（I）**这种方法常用于增强图像中物体的边缘信息，能够有效地突出高亮区域的外围。</p>
<table>
<thead>
<tr>
<th>检测算法</th>
<th>核心原理</th>
<th>优势</th>
<th>劣势</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>形态学梯度</strong></td>
<td>膨胀 - 腐蚀差值</td>
<td>边缘连续、实时性强、参数可控</td>
<td>抗噪声弱、边缘粗</td>
<td>实时目标轮廓提取、低对比度图像</td>
</tr>
<tr>
<td><strong>Sobel 算子</strong></td>
<td>计算灰度图像梯度幅值（水平 &#x2F; 垂直）</td>
<td>定向边缘检测强、抗噪声较好</td>
<td>边缘离散、对细节敏感</td>
<td>定向边缘提取（道路、文本）</td>
</tr>
<tr>
<td><strong>Canny 算子</strong></td>
<td>高斯平滑→梯度计算→非极大值抑制→双阈值分割</td>
<td>边缘精细、抗噪声强、定位准</td>
<td>计算复杂、实时性弱</td>
<td>高精度边缘检测（医学影像、工业测量）</td>
</tr>
<tr>
<td>以下代码实现基本、内部、外部形态学梯度，可直观观察效果</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># 1. 读取灰度图像</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&quot;sample.jpg&quot;, 0) # 0表示灰度模式</span><br><span class="line"></span><br><span class="line"># 2. 定义结构元素（3×3正方形，可调整为(5,5)等）</span><br><span class="line"></span><br><span class="line">kernel = np.ones((3, 3), np.uint8)</span><br><span class="line"></span><br><span class="line"># 3. 计算三种梯度</span><br><span class="line"></span><br><span class="line">basic_gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel) # 基本梯度</span><br><span class="line"></span><br><span class="line">internal_gradient = img - cv2.morphologyEx(img, cv2.MORPH_ERODE, kernel) # 内部梯度</span><br><span class="line"></span><br><span class="line">external_gradient = cv2.morphologyEx(img, cv2.MORPH_DILATE, kernel) - img # 外部梯度</span><br><span class="line"></span><br><span class="line"># 4. 显示结果</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(12, 8))</span><br><span class="line"></span><br><span class="line">plt.subplot(221), plt.imshow(img, cmap=&quot;gray&quot;), plt.title(&quot;原始图像&quot;)</span><br><span class="line"></span><br><span class="line">plt.subplot(222), plt.imshow(basic_gradient, cmap=&quot;gray&quot;), plt.title(&quot;基本梯度&quot;)</span><br><span class="line"></span><br><span class="line">plt.subplot(223), plt.imshow(internal_gradient, cmap=&quot;gray&quot;), plt.title(&quot;内部梯度&quot;)</span><br><span class="line"></span><br><span class="line">plt.subplot(224), plt.imshow(external_gradient, cmap=&quot;gray&quot;), plt.title(&quot;外部梯度&quot;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="顶帽运算"><a href="#顶帽运算" class="headerlink" title="顶帽运算"></a>顶帽运算</h4><p>顶帽运算，又称 “礼帽运算”，是数字图像处理中<strong>基于形态学操作</strong>的重要技术，核心是通过 “开运算” 与原始图像的差值，提取图像中比周围背景更亮的细小区域（如亮斑、亮线条），广泛应用于图像预处理中的细节增强、噪声去除等场景。<br>顶帽运算的本质是<strong>原始图像减去其开运算结果</strong></p>
<h4 id="黑帽运算"><a href="#黑帽运算" class="headerlink" title="黑帽运算"></a>黑帽运算</h4><p>黑帽运算，是数字图像处理中<strong>基于形态学操作</strong>的关键技术，核心是通过 “闭运算” 与原始图像的差值，提取图像中比周围背景更暗的细小区域（如暗斑、暗线条），常与顶帽运算配合，用于暗细节增强、目标检测等场景，是图像预处理的重要工具之一。<br>黑帽运算的本质是<strong>对原始图像进行闭运算后，用闭运算结果减去原始图像</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>顶帽运算（Top-Hat）</th>
<th>黑帽运算（Black-Hat）</th>
</tr>
</thead>
<tbody><tr>
<td>核心公式</td>
<td>I - Opening(I)</td>
<td>Closing (I) - I（闭运算减原始图像）</td>
</tr>
<tr>
<td>提取目标</td>
<td>比背景更亮的细小区域</td>
<td>比背景更暗的细小区域</td>
</tr>
<tr>
<td>典型用途</td>
<td>提取亮斑、亮线条</td>
<td>提取暗斑、暗线条</td>
</tr>
<tr>
<td>适用场景</td>
<td>深色背景中的亮目标检测</td>
<td>浅色背景中的暗目标检测</td>
</tr>
</tbody></table>
<h3 id="图像运算"><a href="#图像运算" class="headerlink" title="图像运算"></a>图像运算</h3><h4 id="加add-a-b"><a href="#加add-a-b" class="headerlink" title="加add(a,b)"></a>加add(a,b)</h4><p>变亮</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_lena = cv2.imread(&#x27;img/lena.png&#x27;)</span><br><span class="line">img = np.ones_like(img_lena) * 100</span><br><span class="line">img_result = cv2.add(img_lena, img)</span><br></pre></td></tr></table></figure>
<h4 id="减subtract-a-b"><a href="#减subtract-a-b" class="headerlink" title="减subtract(a,b)"></a>减subtract(a,b)</h4><p>变暗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img_lena = cv2.imread(&#x27;img/lena.png&#x27;)</span><br><span class="line">img = np.ones_like(img_lena) * 100</span><br><span class="line">img_result = cv2.subtract(img_lena, img)</span><br></pre></td></tr></table></figure>
<h4 id="图像的乘法multiply-a-b-变亮更快"><a href="#图像的乘法multiply-a-b-变亮更快" class="headerlink" title="图像的乘法multiply(a, b)变亮更快"></a>图像的乘法multiply(a, b)变亮更快</h4><h4 id="图像的除法divide-a-b-变暗更快"><a href="#图像的除法divide-a-b-变暗更快" class="headerlink" title="图像的除法divide(a, b)变暗更快"></a>图像的除法divide(a, b)变暗更快</h4><h4 id="图像的溶合addWeighted-A-alpha-B-beta-gamma"><a href="#图像的溶合addWeighted-A-alpha-B-beta-gamma" class="headerlink" title="图像的溶合addWeighted(A, alpha, B, beta, gamma)"></a>图像的溶合addWeighted(A, alpha, B, beta, gamma)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addWeighted(A, alpha, B, beta, gamma)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：<br> alpha和beta是权重，两者和是1<br> gamma静态权重</p>
</blockquote>
<p>要求两个图像的shape完全一致</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resize(src, dsize, fx=None, fy=None, interpolation=None)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> src：输入原图像。<br> dsize：输出图像的大小，格式为(宽,高)。如果为0，则需要指定fx和fy。<br> fx：沿x轴的缩放比例。设置dsize可以不用设置fx和fy。<br> fy：沿y轴的缩放比例。</p>
</blockquote>
<h4 id="图像的位运算-非操作bitwise-not-img"><a href="#图像的位运算-非操作bitwise-not-img" class="headerlink" title="图像的位运算-非操作bitwise_not(img)"></a>图像的位运算-非操作bitwise_not(img)</h4><h4 id="图像的位运算-与操作bitwise-and-img1-img2"><a href="#图像的位运算-与操作bitwise-and-img1-img2" class="headerlink" title="图像的位运算-与操作bitwise_and(img1, img2)"></a>图像的位运算-与操作bitwise_and(img1, img2)</h4><h4 id="图像的位运算-或运算、异或运算"><a href="#图像的位运算-或运算、异或运算" class="headerlink" title="图像的位运算-或运算、异或运算"></a>图像的位运算-或运算、异或运算</h4><p>bitwise_or(img1, img2):黑0白1处变为白1，全白为白，全黑为黑<br>bitwise_xor(img1, img2)：黑白处变为白，全白为黑，全黑为黑</p>
<p>四种逻辑运算核心对比</p>
<table>
<thead>
<tr>
<th>运算类型</th>
<th>输入数量</th>
<th>核心规则</th>
<th>关键特征</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td>非（NOT）</td>
<td>1</td>
<td>输入反向（0→1，1→0）</td>
<td>唯一单输入运算，结果与输入完全相反</td>
<td>状态切换、信号反相</td>
</tr>
<tr>
<td>与（AND）</td>
<td>2</td>
<td>全1出1，有0出0</td>
<td>需所有条件满足，结果“严格”为真</td>
<td>多条件同时判断、门禁控制</td>
</tr>
<tr>
<td>或（OR）</td>
<td>2</td>
<td>有1出1，全0出0</td>
<td>至少一个条件满足，结果“包容”为真</td>
<td>多条件任选判断、故障报警</td>
</tr>
<tr>
<td>异或（XOR）</td>
<td>2</td>
<td>同出0，异出1</td>
<td>条件互斥，不能同时满足</td>
<td>数据加密、奇偶校验、数值交换</td>
</tr>
</tbody></table>
<h3 id="图像几何学变换"><a href="#图像几何学变换" class="headerlink" title="图像几何学变换"></a>图像几何学变换</h3><h4 id="缩放cv2-resize"><a href="#缩放cv2-resize" class="headerlink" title="缩放cv2.resize( )"></a>缩放cv2.resize( )</h4><p>用于调整图像的大小（即图像的缩放）。这个函数可以将图像缩放到指定的尺寸，同时保持图像的宽高比（除非指定了新的宽高比）。图像缩放是图像处理中的基本操作之一，常用于图像预处理、数据增强或适应不同的显示设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.resize(src, dsize [, fx[, fy[, interpolation]]])</span><br><span class="line">• src：输入图像，即要缩放的原始图像。</span><br><span class="line">• dsize：输出图像的尺寸，通常是一个元组 (width, height)。如果指定了这个参数，那么 fx 和 fy 将被忽略。</span><br><span class="line">• fx：宽度方向的缩放因子。如果指定了 dsize，则这个参数将被忽略。否则，它决定了输出图像的宽度是输入图像宽度的多少倍。</span><br><span class="line">• fy：高度方向的缩放因子。如果指定了 dsize，则这个参数将被忽略。否则，它决定了输出图像的高度是输入图像高度的多少倍。</span><br><span class="line">• interpolation：插值方法，用于决定图像缩放时像素值的计算方式。OpenCV 提供了多种插值方法，如 cv2.INTER_LINEAR（线性插值，默认值）、cv2.INTER_NEAREST（最近邻插值）、cv2.INTER_CUBIC（三次样条插值）、cv2.INTER_AREA（效果最好）等。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">函数返回缩放后的图像。如果指定了 dst 参数，则函数不返回值，而是将结果存储在 dst 中。</span><br></pre></td></tr></table></figure>

<p><strong>在numpy中，先行后列，所以是[y, x]。对于opencv来说，讲究坐标xy。两者转换。</strong></p>
<h4 id="翻转cv2-flip"><a href="#翻转cv2-flip" class="headerlink" title="翻转cv2.flip( )"></a>翻转cv2.flip( )</h4><p>用于翻转图像。这个函数可以沿水平轴、垂直轴或同时沿两个轴翻转图像，从而得到镜像效果。函数根据指定的翻转标志对输入图像进行翻转操作。翻转是逐像素进行的，不改变图像的分辨率或颜色空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.flip(src, flipCode)</span><br><span class="line">• src：输入图像，即要翻转的原图像。</span><br><span class="line">• flipCode</span><br><span class="line">：翻转的标志，控制翻转的方式。它可以是以下值之一：</span><br><span class="line">  0：表示绕x轴进行上下翻转。</span><br><span class="line">  1：表示绕y轴进行左右翻转。</span><br><span class="line"> -1：表示同时沿 x 轴和 y 轴翻转（水平和垂直翻转），相当于将图像旋转 180 度。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">函数返回翻转后的图像，与输入图像具有相同的类型和大小。</span><br></pre></td></tr></table></figure>
<h4 id="旋转cv2-rotate"><a href="#旋转cv2-rotate" class="headerlink" title="旋转cv2.rotate( )"></a>旋转cv2.rotate( )</h4><p> 可以对图像进行 90 度、180 度或 270 度的旋转。这个函数非常适合快速实现简单的旋转操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cv2.rotate(src, rotateCode)</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">1. src: 输入图像（需要旋转的图像）。</span><br><span class="line">2. rotateCode: 旋转代码，指定旋转的方式。可选值包括：</span><br><span class="line">	 cv2.ROTATE_90_CLOCKWISE: 顺时针旋转 90 度。</span><br><span class="line">	 cv2.ROTATE_180: 旋转 180 度。</span><br><span class="line">	 cv2.ROTATE_90_COUNTERCLOCKWISE: 逆时针旋转 90 度（相当于顺时针旋转 270 度）。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">• 返回旋转后的图像。</span><br></pre></td></tr></table></figure>
<h4 id="平移cv2-warpAffine"><a href="#平移cv2-warpAffine" class="headerlink" title="平移cv2.warpAffine( )"></a>平移cv2.warpAffine( )</h4><p>图像平移（Image Translation）是图像处理中的一种基本几何变换，指的是将图像中的所有像素点沿着水平方向（x 轴）和&#x2F;或垂直方向（y 轴）移动一定的距离。平移不会改变图像的内容，只会改变图像的位置。</p>
<p>平移可以用以下变换矩阵表示：<br>M &#x3D;<br> [1 0 tx]<br> [0 1 ty]<br>tx 是水平方向（x 轴）的平移距离。ty 是垂直方向（y 轴）的平移距离。<br>对于图像中的每个像素点 (x, y)，平移后的新坐标 (x’, y’) 可以通过以下公式计算：<br>x’ &#x3D; x + tx<br>y’ &#x3D; y + ty</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 对图像进行翻转操作</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"># 1. 读取图片</span><br><span class="line">image = cv2.imread(&#x27;./img/lena.png&#x27;)</span><br><span class="line">h, w, ch = image.shape</span><br><span class="line"># 手动创建变换矩阵2x2单元矩阵,然后横向偏移100，竖向不进行偏移.</span><br><span class="line"># 必须是float32，要求精度</span><br><span class="line">M = np.float32([[1, 0, 100], [0, 1, 0]])</span><br><span class="line"># 竖向平移300</span><br><span class="line"># M = np.float32([[1, 0, 100], [0, 1, 300]])</span><br><span class="line">img_new = cv2.warpAffine(image, M, (w, h))</span><br><span class="line"># 3. 输出，显示</span><br><span class="line">cv2.imshow(&#x27;image&#x27;, image)</span><br><span class="line">cv2.imshow(&#x27;img_new&#x27;, img_new)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<h4 id="变换矩阵getRotationMatrix2D"><a href="#变换矩阵getRotationMatrix2D" class="headerlink" title="变换矩阵getRotationMatrix2D( )"></a>变换矩阵getRotationMatrix2D( )</h4><p>cv2.getRotationMatrix2D 是 OpenCV 库中的一个函数，用于计算二维图像的旋转矩阵。这个旋转矩阵可以将图像绕指定的中心点旋转一定的角度，同时保持图像的尺寸不变（除非另外指定）。这个函数通常用于图像的旋转操作。函数根据指定的旋转中心、旋转角度和缩放因子计算出一个旋转矩阵。这个矩阵描述了图像如何绕中心点旋转，并且（如果指定了缩放因子）如何缩放。旋转是相对于图像坐标系的原点进行的，但可以通过指定不同的中心点来改变旋转的轴心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.getRotationMatrix2D(center, angle, scale)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.getRotationMatrix2D(center, angle, scale)</span><br><span class="line">• center：旋转的中心点坐标，通常是一个元组 (x, y)。</span><br><span class="line">• angle：旋转的角度，以度为单位。正值表示逆时针旋转，负值表示顺时针旋转。</span><br><span class="line">• scale：图像缩放因子。默认值是 1.0，表示不缩放图像。如果需要缩放图像，可以指定一个大于或小于 1.0 的值。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">函数返回一个 2x3 的 NumPy 数组，表示旋转矩阵。这个矩阵可以用于后续的图像变换操作，如 cv2.warpAffine 函数，来实际旋转图像。</span><br><span class="line">M = </span><br><span class="line">[[a, b, c],</span><br><span class="line"> [d, e, f]]</span><br><span class="line">其中：</span><br><span class="line">• a = scale * cos(angle)</span><br><span class="line">• b = scale * sin(angle)</span><br><span class="line">• c = (1 - a) * center_x - b * center_y</span><br><span class="line">• d = -scale * sin(angle)</span><br><span class="line">• e = scale * cos(angle)</span><br><span class="line">• f = (1 - e) * center_y - d * center_x</span><br></pre></td></tr></table></figure>

<h4 id="仿射变换-warpaffine"><a href="#仿射变换-warpaffine" class="headerlink" title="仿射变换 warpaffine( )"></a>仿射变换 warpaffine( )</h4><p>cv2.warpAffine 是 OpenCV 中用于执行仿射变换的函数。仿射变换是一种线性变换，包括<strong>平移、旋转、缩放和剪切</strong>等操作。cv2.warpAffine 可以根据提供的变换矩阵对图像进行几何变换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.warpAffine(src, M, dsize, flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT, borderValue=0)</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>参数</strong></p>
<ol>
<li><strong>src</strong>: 输入图像。</li>
<li><strong>M</strong>: 2x3 的变换矩阵（通常通过 cv2.getRotationMatrix2D 或其他方法生成）。</li>
<li><strong>dsize</strong>: 输出图像的尺寸，格式为 (width, height)。</li>
<li><strong>flags</strong>: （可选）插值方法，默认为 cv2.INTER_LINEAR。常见选项包括：</li>
</ol>
<ul>
<li>cv2.INTER_NEAREST: 最近邻插值。</li>
<li>cv2.INTER_LINEAR: 双线性插值（默认）。</li>
<li>cv2.INTER_CUBIC: 双三次插值。</li>
<li>cv2.INTER_AREA: 区域插值（适合缩小图像）。</li>
</ul>
<ol start="6">
<li><strong>borderMode</strong>: （可选）边界填充模式，默认为 cv2.BORDER_CONSTANT。常见选项：</li>
</ol>
<ul>
<li>cv2.BORDER_CONSTANT: 用固定值填充边界。</li>
<li>cv2.BORDER_REPLICATE: 复制边界像素。</li>
<li>cv2.BORDER_REFLECT: 反射边界像素。</li>
</ul>
<ol start="8">
<li><strong>borderValue</strong>: （可选）当 borderMode&#x3D;cv2.BORDER_CONSTANT 时，用于填充边界的值，默认为 0（黑色）。</li>
</ol>
<p><strong>返回值</strong><br>返回变换后的图像。</p>
</blockquote>
<h3 id="插值方法"><a href="#插值方法" class="headerlink" title="插值方法"></a>插值方法</h3><p>像插值算法是为了解决图像缩放或者旋转等操作时，由于像素之间的间隔不一致而导致的信息丢失和图像质量下降的问题。当我们对图像进行缩放或旋转等操作时，需要在新的像素位置上计算出对应的像素值，而插值算法的作用就是根据已知的像素值来推测未知位置的像素值。<br>图形仿射变换插值方法主要用于在变换过程中平滑处理像素或顶点的位置变化。常见的插值方法包括最近邻插值、双线性插值和双三次插值，它们的主要区别如下：</p>
<ol>
<li><p>最近邻插值（Nearest Neighbor Interpolation）<br>• 原理：选择离目标点最近的像素值。<br>• 优点：计算简单，速度快。<br>• 缺点：图像质量较低，容易出现锯齿。<br>• 适用场景：对实时性要求高、图像质量要求不高的场景。</p>
</li>
<li><p>双线性插值（Bilinear Interpolation）<br>• 原理：利用目标点周围四个最近像素，通过线性插值计算新像素值。<br>• 优点：图像质量较好，计算适中。<br>• 缺点：可能导致图像模糊。<br>• 适用场景：图像质量要求较高、计算资源有限的场景。</p>
</li>
<li><p>双三次插值（Bicubic Interpolation）<br>• 原理：利用目标点周围16个像素，通过三次多项式插值计算新像素值。<br>• 优点：图像质量高，细节保留较好。<br>• 缺点：计算复杂，速度较慢。<br>• 适用场景：对图像质量要求极高的场景，如专业图像处理。</p>
</li>
<li><p>Lanczos插值<br>• 原理：使用Lanczos窗口函数进行插值，考虑更多周围像素。<br>• 优点：图像质量非常高，细节和边缘保持较好。<br>• 缺点：计算复杂，速度慢。<br>• 适用场景：高质量图像缩放和变换。</p>
</li>
</ol>
<p>总结<br>• 最近邻插值：速度快，质量低。<br>• 双线性插值：质量较好，计算适中。<br>• 双三次插值：质量高，计算复杂。<br>• Lanczos插值：质量最高，计算最复杂。</p>
<h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><h4 id="边界复制（cv2-BORDER-REPLICATE）"><a href="#边界复制（cv2-BORDER-REPLICATE）" class="headerlink" title="边界复制（cv2.BORDER_REPLICATE）"></a>边界复制（cv2.BORDER_REPLICATE）</h4><h4 id="边界反射-cv2-BORDER-REFLECT"><a href="#边界反射-cv2-BORDER-REFLECT" class="headerlink" title="边界反射(cv2.BORDER_REFLECT)"></a>边界反射(cv2.BORDER_REFLECT)</h4><h4 id="边界反射101-cv2-BORDER-REFLECT-101"><a href="#边界反射101-cv2-BORDER-REFLECT-101" class="headerlink" title="边界反射101(cv2.BORDER_REFLECT_101)"></a>边界反射101(cv2.BORDER_REFLECT_101)</h4><h4 id="常数填充（cv2-BORDER-CONSTANT）"><a href="#常数填充（cv2-BORDER-CONSTANT）" class="headerlink" title="常数填充（cv2.BORDER_CONSTANT）"></a>常数填充（cv2.BORDER_CONSTANT）</h4><h4 id="外包装（cv2-BORDER-WRAP）"><a href="#外包装（cv2-BORDER-WRAP）" class="headerlink" title="外包装（cv2.BORDER_WRAP）"></a>外包装（cv2.BORDER_WRAP）</h4><h3 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h3><p>图像的透视变换（Perspective Transformation）是一种将图像从一个视角投影到另一个视角的几何变换。与仿射变换（Affine Transformation）不同，透视变换可以处理更复杂的几何变形，例如将倾斜的图像校正为正面视角，或将图像投影到某个平面上。</p>
<p>透视变换的特点</p>
<ol>
<li><p>非线性变换：<br> 透视变换是非线性的，可以处理图像的透视效果（近大远小）。<br> 仿射变换是线性变换，只能处理旋转、平移、缩放和剪切。</p>
</li>
<li><p>保持直线性：<br> 透视变换后，图像中的直线仍然是直线，但直线的角度和长度可能会发生变化。</p>
</li>
<li><p>应用场景：<br> 图像校正（如文档校正、车牌校正）。<br> 虚拟视角变换（如将图像投影到某个平面上）。<br> 3D 视觉效果（如将 2D 图像映射到 3D 空间）。</p>
</li>
</ol>
<p>OpenCV 提供了 cv2.getPerspectiveTransform 和 cv2.warpPerspective 函数来实现透视变换。</p>
<h4 id="透视变换矩阵getPerspectiveTransform"><a href="#透视变换矩阵getPerspectiveTransform" class="headerlink" title="透视变换矩阵getPerspectiveTransform"></a>透视变换矩阵getPerspectiveTransform</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.getPerspectiveTransform(src, dst)</span><br></pre></td></tr></table></figure>
<p>• src: 源图像中的 4 个点的坐标，形状为 (4, 2)，数据类型为 float32。<br>• dst: 目标图像中对应的 4 个点的坐标，形状为 (4, 2)，数据类型为 float32。<br>• 返回值: 一个 3x3 的透视变换矩阵，数据类型为 float32</p>
<h4 id="透视变换warpPerspective"><a href="#透视变换warpPerspective" class="headerlink" title="透视变换warpPerspective"></a>透视变换warpPerspective</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.warpPerspective(src, M, dsize, dst=None, flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT, borderValue=0)</span><br></pre></td></tr></table></figure>

<p>• src: 输入图像。<br>• M: 3x3 的透视变换矩阵。<br>• dsize: 输出图像的尺寸，格式为 (width, height)。<br>• flags: 插值方法，默认为 cv2.INTER_LINEAR。<br>• borderMode: 边界填充模式，默认为 cv2.BORDER_CONSTANT。<br>• borderValue: 边界填充值，默认为 0（黑色）。</p>
<h3 id="滤波"><a href="#滤波" class="headerlink" title="滤波"></a>滤波</h3><h4 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h4><h5 id="二维卷积filter2D"><a href="#二维卷积filter2D" class="headerlink" title="二维卷积filter2D"></a>二维卷积filter2D</h5><p>通过自定义卷积核，可以实现各种低通滤波效果。<br>是 OpenCV 中用于对图像进行二维卷积操作的函数。它可以对图像应用自定义的卷积核（Kernel），从而实现各种图像处理效果，如模糊、锐化、边缘检测等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.filter2D(**src, ddepth, kernel,** anchor=None, delta=None, borderType=None)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明</p>
<ol>
<li>src: 输入图像，可以是单通道或多通道图像。</li>
<li>ddepth: 输出图像的深度（数据类型）。通常设置为 -1，表示输出图像与输入图像具有相同的深度。</li>
<li>kernel: 卷积核（滤波器），是一个二维数组（NumPy 数组）。</li>
<li>anchor: （可选）卷积核的锚点，默认为 (-1, -1)，表示锚点位于卷积核的中心。</li>
<li>delta: （可选）在卷积操作后添加到每个像素值的常数，默认为 0。</li>
<li>borderType: （可选）边界填充模式，默认为 cv2.BORDER_DEFAULT。常见的边界填充模式包括：<br>cv2.BORDER_CONSTANT: 用固定值填充边界。<br>cv2.BORDER_REPLICATE: 复制边界像素。<br>cv2.BORDER_REFLECT: 反射边界像素。</li>
</ol>
<p>返回值  返回卷积操作后的图像。</p>
</blockquote>
<h5 id="均值滤波cv2-blur"><a href="#均值滤波cv2-blur" class="headerlink" title="均值滤波cv2.blur"></a>均值滤波cv2.blur</h5><p>均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值。<br>比如有一张4<em>4的图片，现在使用一个3</em>3的卷积核进行均值滤波，也就是卷积核对图片进行卷积，为了确保卷积核的中心能够对准边界的像素点进行滤波操作，对于边界的像素点，则会进行边界填充。在OpenCV中，默认的是使用BORDER_REFLECT_101的方式进行填充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.blur(src, ksize[,anchor[, borderType]])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">• src：输入图像，可以是多通道图像。</span><br><span class="line">• ksize：模糊核的大小。它是一个元组，表示核的宽度和高度，比如 (3, 3) 或 (5, 5)。核的大小应该是正奇数，且宽度和高度可以相同也可以不同。核越大，模糊效果越明显。</span><br><span class="line">• anchor：锚点（可选）。它表示核的中心点位置，通常默认为 (-1, -1)，意味着核的中心位于当前像素点。对于大多数情况，这个参数不需要修改。</span><br><span class="line">• borderType：边界填充类型（可选）。这个参数用于指定边界外像素的外推方法，比如 cv2.BORDER_DEFAULT、cv2.BORDER_REFLECT 等。在大多数情况下，默认值就足够了。</span><br></pre></td></tr></table></figure>


<h5 id="方框滤波-cv2-boxFilter"><a href="#方框滤波-cv2-boxFilter" class="headerlink" title="方框滤波 cv2.boxFilter"></a>方框滤波 cv2.boxFilter</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.boxFilter(src, ddepth, ksize, anchor=None, normalize=None, borderType=None)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">参数说明</span><br><span class="line">1. src: 输入图像，可以是单通道或多通道图像。</span><br><span class="line">2. ddepth: 输出图像的深度（数据类型）。通常设置为 -1，表示输出图像与输入图像具有相同的深度。</span><br><span class="line">3. ksize: 滤波器的大小，格式为 (width, height)。例如，(5, 5) 表示一个 5x5 的滤波器。</span><br><span class="line">4. anchor: （可选）滤波器的锚点，默认为 (-1, -1)，表示锚点位于滤波器的中心。</span><br><span class="line">5. normalize: （可选）是否对滤波器进行归一化。默认为 True，表示对滤波器进行归一化（即取平均值）。如果设置为 False，则直接对邻域像素求和。</span><br><span class="line">6. borderType: （可选）边界填充模式，默认为 cv2.BORDER_DEFAULT。常见的边界填充模式包括：</span><br><span class="line"> cv2.BORDER_CONSTANT: 用固定值填充边界。</span><br><span class="line"> cv2.BORDER_REPLICATE: 复制边界像素。</span><br><span class="line"> cv2.BORDER_REFLECT: 反射边界像素。</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">• 返回滤波后的图像。</span><br></pre></td></tr></table></figure>
<p>normalize&#x3D;True等同于均值滤波</p>
<h5 id="高斯滤波-cv2-GaussianBlur"><a href="#高斯滤波-cv2-GaussianBlur" class="headerlink" title="高斯滤波 cv2.GaussianBlur"></a>高斯滤波 cv2.GaussianBlur</h5><p>前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小。<br>cv2.GaussianBlur 是 OpenCV 库中的一个函数，用于对图像进行高斯模糊处理。高斯模糊是一种图像平滑技术，它通过与高斯函数核进行卷积来减少图像中的噪声和细节，使得图像变得更加平滑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">• src：输入图像，可以是多通道图像。</span><br><span class="line">• ksize：高斯核的大小。它应该是一个正奇数，比如 (3, 3) 或 (5, 5)。这个值决定了模糊的程度，核越大，模糊效果越明显。</span><br><span class="line">• sigmaX：高斯核函数在 X 方向的标准偏差。这个参数控制了模糊的程度，值越大，模糊效果越强。</span><br><span class="line">• dst：输出图像（可选）。如果指定了这个参数，函数将把结果写入这个图像中，而不是创建一个新的图像。</span><br><span class="line">• sigmaY：高斯核函数在 Y 方向的标准偏差（可选）。如果这个值为 0，那么函数会根据 sigmaX 的值来计算 Y 方向的标准偏差。如果 sigmaY 不为 0，那么它将独立地控制 Y 方向的模糊程度。</span><br><span class="line">• borderType：边界填充类型（可选）。这个参数用于指定边界外像素的外推方法，例如 cv2.BORDER_DEFAULT、cv2.BORDER_REFLECT 等。</span><br><span class="line"></span><br><span class="line">‌返回值‌：</span><br><span class="line">函数返回的是模糊处理后的图像。</span><br></pre></td></tr></table></figure>

<h5 id="中值滤波-cv2-medianBlur"><a href="#中值滤波-cv2-medianBlur" class="headerlink" title="中值滤波 cv2.medianBlur"></a>中值滤波 cv2.medianBlur</h5><p>中值又叫中位数，是所有数排序后取中间的值。中值滤波没有核值，而是在原图中从左上角开始，将卷积核区域内的像素值进行排序，并选取中值作为卷积核的中点的像素值，其过程如下所示：<br>中值滤波就是用区域内的中值来代替本像素值，所以那种孤立的斑点，如0或255很容易消除掉，适用于去除椒盐噪声和斑点噪声。中值是一种非线性操作，效率相比前面几种线性滤波要慢。</p>
<h5 id="双边滤波-cv2-bilateralFilter"><a href="#双边滤波-cv2-bilateralFilter" class="headerlink" title="双边滤波 cv2.bilateralFilter"></a>双边滤波 cv2.bilateralFilter</h5><p>模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了双边滤波。<br>双边滤波是一种非线性的、边缘保持的、降噪的滤波器，它能够在平滑图像的同时保留边缘细节。与高斯滤波等线性滤波器不同，双边滤波同时考虑了空间距离和像素值之间的差异，因此能够在降噪的同时更好地保留图像的边缘信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst[, borderType]])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">• src：输入图像，可以是多通道图像。</span><br><span class="line">• d：在滤波过程中一个像素邻域的直径。如果这个值是负数，那么它会被计算为从 sigmaSpace 推导出来的值。</span><br><span class="line">• sigmaColor：颜色空间滤波器的 sigma 值。这个参数决定了多少邻域内的像素会被考虑在内，基于它们的颜色相似度。一个较大的值意味着更宽的色彩范围会被认为相似，并且参与到滤波过程中。</span><br><span class="line">• sigmaSpace：坐标空间滤波器的 sigma 值。这个参数决定了多少邻域内的像素会被考虑在内，基于它们的空间位置。一个较大的值意味着更远的像素会被考虑进来进行滤波。</span><br><span class="line">• dst：输出图像（可选）。如果指定了这个参数，函数将把结果写入这个图像中，而不是创建一个新的图像。</span><br><span class="line">• borderType：边界填充类型（可选）。这个参数用于指定在处理边界像素时应该采用哪种边界模式，比如 cv2.BORDER_DEFAULT。</span><br><span class="line"></span><br><span class="line">‌返回值‌：</span><br><span class="line">函数返回的是双边滤波处理后的图像。</span><br></pre></td></tr></table></figure>
<h4 id="高通滤波"><a href="#高通滤波" class="headerlink" title="高通滤波"></a>高通滤波</h4><h5 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h5><p>每次只能求一个方向的边缘。要么对dx求导计算竖边；要么对dy求导计算横边<br>cv2.Sobel 是 OpenCV 库中的一个函数，用于计算图像的一阶导数，即图像的梯度。这个函数常用于边缘检测，因为边缘通常对应于图像中灰度值变化最快的地方，也就是梯度最大的地方。Sobel 算子结合了高斯平滑和微分运算，因此它在一定程度上能够抵抗噪声。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.Sobel(src, ddepth, dx, dy, ksize=3[, scale=1, delta=0, borderType= BORDER_DEFAULT)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">• src：输入图像，它可以是灰度图像或彩色图像</span><br><span class="line">• ddepth：输出图像的所需深度。当参数值为 -1 时，输出图像与输入图像具有相同的深度。为了避免梯度值溢出，通常选择更深的数据类型，如 cv2.CV_64F。</span><br><span class="line">• dx：x 方向上的导数阶数,求竖着的边。值0表示不计算 x 方向的导数、1计算一阶导数或2计算二阶导数。</span><br><span class="line">• dy：y 方向上的导数阶数，求横着的边。与 dx 类似，这个值也是 0、1 或 2。</span><br><span class="line">• ksize：Sobel 核的大小，它必须是 1、3、5、7 或 9 中的一个值。核的大小影响了平滑效果和梯度的计算。</span><br><span class="line">• scale：计算梯度时的缩放因子，默认值是 1。它用于控制结果的缩放程度。</span><br><span class="line">• delta：在将计算结果存储到目标图像之前，可选地将其加上一个值。这个参数在默认情况下是 0。</span><br><span class="line">• borderType：边界填充类型（可选）。这个参数用于指定在处理边界像素时应该采用哪种边界模式，比如 cv2.BORDER_DEFAULT。</span><br><span class="line"></span><br><span class="line">‌返回值‌：</span><br><span class="line">• 函数返回的是计算梯度后的图像，它是一个与输入图像大小相同的灰度图像（即使输入是彩色图像，输出也是灰度图像，因为梯度是分别对每个通道计算的，然后可能会合并，但通常只关心灰度梯度）。</span><br></pre></td></tr></table></figure>
<h5 id="Laplacian算子"><a href="#Laplacian算子" class="headerlink" title="Laplacian算子"></a>Laplacian算子</h5><p>cv2.Laplacian 是 OpenCV 库中的一个函数，用于计算图像的拉普拉斯算子（Laplacian Operator）。拉普拉斯算子是一种二阶微分算子，常用于图像的边缘检测，因为它能够突出图像中的强度变化，特别是边缘部分。在图像处理中，拉普拉斯算子通常用于检测图像中的区域之间的边界。<br>可以同时求两个方向的边缘，对噪音敏感，需要先去噪。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.Laplacian(src, ddepth, ksize=1, scale=1, delta=0, borderType=BORDER_DEFAULT)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">• src：输入图像，它应该是灰度图像。</span><br><span class="line">• ddepth：输出图像的所需深度。当参数值为 -1 时，输出图像与输入图像具有相同的深度。</span><br><span class="line">• ksize：滤波器的大小，它必须是正奇数。默认值是 1，表示不进行额外的平滑处理，直接使用拉普拉斯核。如果你想在进行拉普拉斯变换之前对图像进行平滑处理，可以设置一个更大的值。</span><br><span class="line">• scale：计算拉普拉斯算子时的缩放因子，默认值是 1。它用于控制结果的缩放程度。</span><br><span class="line">• delta：在将计算结果存储到目标图像之前，可选地将其加上一个值。这个参数在默认情况下是 0。</span><br><span class="line">• borderType：边界填充类型（可选）。这个参数用于指定在处理边界像素时应该采用哪种边界模式，比如 cv2.BORDER_DEFAULT。</span><br><span class="line">‌返回值‌：</span><br><span class="line">• 函数返回的是计算拉普拉斯算子后的图像，它通常是一个与输入图像大小相同的灰度图像，但突出了边缘部分。</span><br></pre></td></tr></table></figure>


<h4 id="滤波FAQ"><a href="#滤波FAQ" class="headerlink" title="滤波FAQ"></a>滤波FAQ</h4><p>低通滤波是一种信号处理技术，用于去除高频成分，保留低频成分。在图像处理和信号处理中，低通滤波常用于平滑图像、降噪或模糊处理。</p>
<p>低通滤波与高通滤波：<br>低通滤波可以去除噪音或平滑图像:<br>线性：均值滤波、方框滤波、高斯滤波、<br>非线性：中值滤波、双边滤波<br>高通滤波可以帮助查找图像的边缘。<br>每次只能求一个方向的边缘。要么对dx求导计算竖边；要么对dy求导计算横边</p>
<p>1.高斯滤波代码会写<br>2.在不知道用什么滤波器好的时候，优先高斯滤波，然后均值滤波。<br>斑点和椒盐噪声优先使用中值滤波。<br>要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波。</p>
<p>线性滤波方式：均值滤波、方框滤波(normalize&#x3D;True等同于均值滤波)、高斯滤波（速度相对快）。<br>非线性滤波方式：中值滤波、双边滤波（速度相对慢）。</p>
<p>sobel只考虑水平或者垂直一个方向的梯度<br>Laplacian滤波核就是,计算上下左右的和卷积核中心点的梯度</p>
<h3 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-   image：输入图像，必须是**灰度图像**。</span><br><span class="line">-   threshold1：第一个阈值（低阈值）。</span><br><span class="line">-   threshold2：第二个阈值（高阈值）。设置的值小保留边缘多，值大保留边缘少。</span><br><span class="line">-   edges（可选）：输出边缘图，通常不需要指定，函数会返回一个新的边缘图。</span><br><span class="line">-   apertureSize：Sobel算子的大小（可选），默认值是3。</span><br><span class="line">-   L2gradient：一个布尔值，指示是否使用L2范数进行梯度计算（可选），默认值是False。</span><br></pre></td></tr></table></figure>

<p>Canny算法的步骤：</p>
<ul>
<li>高斯模糊去噪</li>
<li>计算梯度强度和方向</li>
<li>非极大值抑制</li>
<li>双阈值检测和边缘连接</li>
</ul>
<h4 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h4><h5 id="寻找轮廓cv2-findContours"><a href="#寻找轮廓cv2-findContours" class="headerlink" title="寻找轮廓cv2.findContours()"></a>寻找轮廓cv2.findContours()</h5><p>寻找轮廓需要将图像做一个二值化处理，并且根据图像的不同选择不同的二值化方法来将图像中要<strong>绘制轮廓的部分置为白色，其余部分置为黑色</strong>。也就是说，我们需要对原始的图像进行灰度化、二值化的处理，令目标区域显示为白色，其他区域显示为黑色。<br>cv2.findContours 是 OpenCV 库中用于检测图像轮廓的函数。它通常用于图像处理中的对象检测、形状分析等任务。该函数会返回图像中所有检测到的轮廓。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contours,hierarchy = cv2.findContours(image，mode，method)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**参数说明**</span><br><span class="line"></span><br><span class="line">1.  **image**: 输入图像，通常是二值化后的图像（例如经过阈值处理或边缘检测后的图像）。注意，cv2.findContours 会直接修改输入图像，因此如果需要保留原图，请先复制一份。</span><br><span class="line">2.  **mode**: 轮廓检索模式，决定如何提取轮廓。常用的模式有：</span><br><span class="line">-   **cv2.RETR_EXTERNAL:** 只检测最外层的轮廓。</span><br><span class="line">-   cv2.RETR_LIST: 检测所有轮廓，但不建立轮廓之间的层级关系。</span><br><span class="line">-   cv2.RETR_TREE: 检测所有轮廓，并建立完整的轮廓层级关系。</span><br><span class="line">3.  **method**: 轮廓近似方法，决定如何存储轮廓点。常用的方法有：</span><br><span class="line">-   cv2.CHAIN_APPROX_NONE: 存储所有轮廓点。</span><br><span class="line">-   **cv2.CHAIN_APPROX_SIMPLE:** 压缩水平、垂直和对角方向的轮廓点，只保留端点。</span><br><span class="line"></span><br><span class="line">**返回值**</span><br><span class="line">1.  **contours**: 检测到的轮廓列表。每个轮廓是一个包含轮廓点的数组。</span><br><span class="line">2.  **hierarchy**: 轮廓的层级信息，表示轮廓之间的关系（例如父子关系）。</span><br></pre></td></tr></table></figure>
<h5 id="绘制轮廓cv2-drawContours"><a href="#绘制轮廓cv2-drawContours" class="headerlink" title="绘制轮廓cv2.drawContours"></a>绘制轮廓cv2.drawContours</h5><p>cv2.drawContours 是 OpenCV 库中的一个函数，用于在图像上绘制轮廓。这个函数通常用于图像处理中，特别是在进行轮廓检测、物体检测等任务时，用于将检测到的轮廓可视化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.drawContours(image, contours, contourIdx, color, thickness=None, lineType=None, hierarchy=None, maxLevel=None, offset=None)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**参数说明**</span><br><span class="line">1.  **image**: 输入图像，轮廓将绘制在此图像上。</span><br><span class="line">2.  **contours**: 轮廓**列表**，通常由 cv2.findContours 返回。</span><br><span class="line">3.  **contourIdx**: 指定要绘制的轮廓索引。如果为负数（例如 -1），则绘制所有轮廓。</span><br><span class="line">4.  **color**: 轮廓的颜色，格式为 (B, G, R)。例如，(0, 255, 0) 表示绿色。</span><br><span class="line">5.  **thickness** (可选): 轮廓线的宽度。如果为负数（例如 -1），则填充轮廓内部。</span><br><span class="line">6.  **lineType** (可选): 线条类型，默认为 cv2.LINE_8。其他选项包括 cv2.LINE_4 和 cv2.LINE_AA（抗锯齿）。</span><br><span class="line">7.  **hierarchy** (可选): 轮廓的层级信息，通常由 cv2.findContours 返回。如果不需要绘制特定层级的轮廓，可以忽略。</span><br><span class="line">8.  **maxLevel** (可选): 绘制轮廓的最大层级。默认为 0，表示只绘制指定的轮廓。</span><br><span class="line">9.  **offset** (可选): 轮廓点的偏移量，通常不需要设置。</span><br></pre></td></tr></table></figure>
<h4 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h4><p>通俗的讲，凸包其实就是将一张图片中物体的最外层的点连接起来构成的凸多边形，它能包含物体中所有的内容。</p>
<h5 id="凸包特征检测cv2-convexHull"><a href="#凸包特征检测cv2-convexHull" class="headerlink" title="凸包特征检测cv2.convexHull"></a>凸包特征检测cv2.convexHull</h5><p>cv2.convexHull 是 OpenCV 中用于计算轮廓的凸包的函数。凸包是包含轮廓所有点的最小凸多边形。它在形状分析、对象检测和手势识别等任务中非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(points[,clockwise[, returnPoints]]])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-   points：输入的点集，通常是一个二维的 Numpy 数组，其中每一行代表一个点的坐标（x, y）。</span><br><span class="line">-   clockwise：布尔值，指示凸包的顶点是否按顺时针方向排列。默认值是 False，表示按逆时针方向排列。</span><br><span class="line">-   returnPoints：布尔值，指示函数是否应返回凸包顶点的坐标。如果为 True（默认值），则函数返回凸包顶点的坐标；如果为 False，则函数返回原始点集中凸包顶点的索引。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">-   当 returnPoints 为 True 时，返回凸包顶点的坐标。</span><br><span class="line">-   当 returnPoints 为 False 时，返回原始点集中凸包顶点的索引。</span><br></pre></td></tr></table></figure>
<h5 id="绘制凸包多边形cv2-polylines"><a href="#绘制凸包多边形cv2-polylines" class="headerlink" title="绘制凸包多边形cv2.polylines"></a>绘制凸包多边形cv2.polylines</h5><p>是 OpenCV 库中的一个函数，用于在图像上绘制多边形线条。这个函数非常适用于在图像上标记或突出显示特定的形状或区域，比如通过轮廓或凸包找到的形状。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.polylines(img, pts, isClosed, color, thickness=1, lineType= LINE_8, shift=0)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-   img：输入/输出参数，这是要绘制多边形的图像。</span><br><span class="line">-   pts：多边形的顶点坐标，通常是一个二维的 Numpy 数组，其中每一行代表一个顶点的坐标（x, y）。对于绘制多个多边形，可以提供一个包含多个多边形顶点集的列表。</span><br><span class="line">-   isClosed：布尔值，指示多边形是否应该闭合。如果设置为 True，则多边形的最后一个顶点将与第一个顶点连接，形成一个闭合的多边形。</span><br><span class="line">-   color：多边形的颜色，通常是一个 BGR（蓝、绿、红）颜色元组，例如 (255, 0, 0) 代表蓝色。</span><br><span class="line">-   thickness：（可选）线条的厚度。默认值是 1。如果你想要更粗的线条，可以增加这个值。</span><br><span class="line">-   lineType：（可选）线条的类型。默认值是 cv2.LINE_8，表示 8-连通线。其他选项包括 cv2.LINE_4（4-连通线）和 cv2.LINE_AA（抗锯齿线），后者通常用于获得更平滑的线条效果。</span><br><span class="line">-   shift：（可选）点坐标的小数位数。默认值是 0。这个参数通常用于绘制非常精确的图形时。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">-   img：这是输入图像的修改版本，现在包含了绘制的多边形线条。</span><br></pre></td></tr></table></figure>
<h4 id="轮廓特征检测-外接矩形"><a href="#轮廓特征检测-外接矩形" class="headerlink" title="轮廓特征检测-外接矩形"></a>轮廓特征检测-外接矩形</h4><p>cv2.boundingRect是 OpenCV 库中的一个函数，用于计算并返回能够完全包含输入轮廓的最小矩形区域的坐标。这个矩形区域是水平的，并且其边与图像坐标轴平行。该函数通常用于轮廓检测、物体检测等任务中，以便快速获取物体的大致位置和尺寸。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y, w, h = cv2.boundingRect(contour)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**参数说明**</span><br><span class="line">-   **contour**: 输入的轮廓点集，通常是由 cv2.findContours 返回的轮廓。</span><br><span class="line"></span><br><span class="line">**返回值**</span><br><span class="line">-   **x, y**: 矩形左上角的坐标。</span><br><span class="line">-   **w, h**: 矩形的宽度和高度。</span><br></pre></td></tr></table></figure>
<h4 id="轮廓特征检测-最小外接矩形"><a href="#轮廓特征检测-最小外接矩形" class="headerlink" title="轮廓特征检测-最小外接矩形"></a>轮廓特征检测-最小外接矩形</h4><h5 id="获取最小外接矩形cv2-minAreaRect"><a href="#获取最小外接矩形cv2-minAreaRect" class="headerlink" title="获取最小外接矩形cv2.minAreaRect"></a>获取最小外接矩形cv2.minAreaRect</h5><p>cv2.minAreaRect是 OpenCV 库中的一个函数，用于计算并返回能够完全包含输入轮廓的最小面积矩形（通常是旋转矩形）的坐标。与 <code>cv2.boundingRect</code> 不同，<code>cv2.minAreaRect</code> 返回的矩形是可能旋转的，以更好地贴合轮廓的形状，从而提供更紧凑的包围。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotated_rect = cv2.minAreaRect(points)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**参数说明**</span><br><span class="line">-   **points**: 输入的点集，通常是一个轮廓（由 cv2.findContours 返回的轮廓点）。</span><br><span class="line"></span><br><span class="line">**返回值**</span><br><span class="line">-   **rotated_rect**: 返回一个旋转矩形，格式为 ((cx, cy), (width, height), angle)，其中：</span><br><span class="line">-   (cx, cy): 矩形中心点坐标。</span><br><span class="line">-   (width, height): 矩形的宽度和高度。</span><br><span class="line">-   angle: 矩形的旋转角度（范围：[-90, 0]）。</span><br></pre></td></tr></table></figure>
<h5 id="获取旋转矩形的四个点坐标cv2-boxPoints"><a href="#获取旋转矩形的四个点坐标cv2-boxPoints" class="headerlink" title="获取旋转矩形的四个点坐标cv2.boxPoints"></a>获取旋转矩形的四个点坐标cv2.boxPoints</h5><p>cv2.boxPoints 是 OpenCV 中用于将旋转矩形（cv2.minAreaRect 返回的结果）转换为四个顶点坐标的函数。旋转矩形由中心点、宽度、高度和旋转角度定义，而 cv2.boxPoints 可以将其转换为四个顶点的坐标，方便绘制或进一步处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">points = cv2.boxPoints(box)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**参数说明**</span><br><span class="line">-   **box**: 旋转矩形，通常由 cv2.minAreaRect 返回，格式为 ((cx, cy), (width, height), angle)。</span><br><span class="line"></span><br><span class="line">**返回值**</span><br><span class="line">-   **points**: 返回旋转矩形的四个顶点坐标，形状为 (4, 2) 的 NumPy 数组。</span><br></pre></td></tr></table></figure>
<h4 id="轮廓特征检测-最小外接圆cv2-minEnclosingCircle"><a href="#轮廓特征检测-最小外接圆cv2-minEnclosingCircle" class="headerlink" title="轮廓特征检测-最小外接圆cv2.minEnclosingCircle"></a>轮廓特征检测-最小外接圆cv2.minEnclosingCircle</h4><p>cv2.minEnclosingCircle是 OpenCV 库中的一个函数，用于找到能够完全包含输入轮廓或点集的最小外接圆。这个函数对于确定一组点的圆形边界非常有用，特别是在进行物体检测、形状分析或聚类分析时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.minEnclosingCircle(points)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-   **points**‌：这是一个二维点集，通常是一个轮廓或一组散点，表示为一个形状为 [-1, 1, 2] 的 NumPy 数组。每一行代表一个点，点的坐标以 (x, y) 的形式给出。</span><br><span class="line">返回值</span><br><span class="line"></span><br><span class="line">该函数返回一个包含三个元素的元组 (center, radius, _)，其中：</span><br><span class="line">-   ‌**center**‌：是一个包含圆心坐标的元组 (x, y)。</span><br><span class="line">-   ‌**radius**‌：是外接圆的半径。</span><br><span class="line">-   第三个返回值是一个可选的布尔值，表示操作是否成功，但在 OpenCV 的 Python 接口中通常不使用这个返回值。</span><br></pre></td></tr></table></figure>
<h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p><strong>模板匹配（Template Matching）</strong> 是一种在图像中查找与给定模板图像最相似区域的技术。它的核心思想是通过滑动模板图像在输入图像上进行比较，找到与模板最匹配的位置。模板匹配广泛应用于目标检测、图像识别、物体跟踪等计算机视觉任务。</p>
<p>cv2.matchTemplate 是 OpenCV 中用于模板匹配的函数。它通过滑动模板图像在输入图像上进行比较，找到最匹配的位置。模板匹配常用于目标检测、图像识别等任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = cv2.matchTemplate(image, templ, method, mask=None)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**参数说明**</span><br><span class="line">1.  **image**: 输入图像，必须是 8 位或 32 位浮点型。</span><br><span class="line">2.  **templ**: 模板图像，大小不能超过输入图像，且数据类型与输入图像相同。</span><br><span class="line">3.  **method**: 匹配方法，指定如何计算匹配程度。常用的方法有：</span><br><span class="line">-   cv2.TM_SQDIFF: 平方差匹配法, 值越小匹配越好。</span><br><span class="line">-   cv2.TM_SQDIFF_NORMED: 归一化平方差匹配法，值越小匹配越好。</span><br><span class="line">-   cv2.TM_CCORR: 相关匹配法，值越大匹配越好。</span><br><span class="line">-   cv2.TM_CCORR_NORMED: 归一化相关匹配法，值越大匹配越好。</span><br><span class="line">-   cv2.TM_CCOEFF: 相关系数匹配法，值越大匹配越好。</span><br><span class="line">-   cv2.TM_CCOEFF_NORMED: 归一化相关系数匹配法，值越大匹配越好。</span><br><span class="line">4.  **mask** (可选): 掩码图像，大小与模板图像相同，用于指定模板图像的哪些部分参与匹配。</span><br><span class="line"></span><br><span class="line">**返回值**</span><br><span class="line">-   **result**: 匹配结果矩阵，每个像素值表示模板与输入图像对应位置的匹配程度。</span><br><span class="line">-   数组的大小为 (W*H)，其中</span><br><span class="line">W = image.cols - templ.cols + 1，</span><br><span class="line">H = image.rows - templ.rows + 1</span><br></pre></td></tr></table></figure>

<p>cv2.minMaxLoc 是 OpenCV 中用于查找数组（通常是图像或矩阵）中最小值和最大值及其位置的函数。它常用于模板匹配、图像分析等任务中，用于定位最佳匹配位置或极值点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(src[, mask])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**参数说明**</span><br><span class="line">1.  **src**: 输入数组（通常是单通道图像或矩阵）。</span><br><span class="line">2.  **mask** (可选): 掩码图像，用于指定只处理掩码非零的区域。</span><br><span class="line"></span><br><span class="line">**返回值**</span><br><span class="line">1.  **min_val**: 数组中的最小值。</span><br><span class="line">2.  **max_val**: 数组中的最大值。</span><br><span class="line">3.  **min_loc**: 最小值的位置，格式为 (x, y)。</span><br><span class="line">4.  **max_loc**: 最大值的位置，格式为 (x, y)。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">image = cv2.imread(&#x27;./img/picture_mb.png&#x27;)</span><br><span class="line">image_tem = cv2.imread(&quot;./img/muban.png&quot;)</span><br><span class="line">cv2.imshow(&#x27;image&#x27;, image)</span><br><span class="line"></span><br><span class="line"># 获取模板图的高和宽，方便后面进行绘图</span><br><span class="line">h, w = image_tem.shape[:2]</span><br><span class="line"></span><br><span class="line"># 进行模板匹配的操作。res中存储模板在原图像上每个位置匹配的结果</span><br><span class="line"># 数组res的大小为 (WxH)，其中W = image.cols - templ.cols + 1，H = image.rows - templ.rows + 1</span><br><span class="line">res = cv2.matchTemplate(image, image_tem, cv2.TM_CCOEFF_NORMED)</span><br><span class="line"># print(&quot;image.shape&quot;, image.shape) # image.shape (321, 346, 3)</span><br><span class="line"># print(&quot;image_tem.shape&quot;, image_tem.shape) # image_tem.shape (27, 16, 3)</span><br><span class="line"># print(&quot;res.shape&quot;, res.shape) # res.shape (295, 331)</span><br><span class="line"># print(res)</span><br><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)</span><br><span class="line"># 对返回的结果做进一步处理.值越大要求匹配度越高，精准度越高。值越小可能匹配度相似度要求越低</span><br><span class="line">threshold = 0.57</span><br><span class="line"># 对某数组的数据进行判断，如果满足条件，就返回其对应值的坐标索引</span><br><span class="line"># 这里要注意的是，他返回的是行和列的坐标。</span><br><span class="line"># 对应到Opencv里，就是某一个点的y和x的坐标</span><br><span class="line">location = np.where(res &gt; threshold)</span><br><span class="line"></span><br><span class="line"># 5. 对得到的点的坐标进行翻转处理，并再原图中框出来</span><br><span class="line"># OpenCV期望的格式是(x, y)，即先列后行。但是np.where返回的是(行, 列)的格式，即(y, x)。</span><br><span class="line"># 为了将这个格式转换为OpenCV期望的格式，我们需要对索引进行翻转。这是取location[::-1]的原因</span><br><span class="line">for left_top in zip(*location[::-1]):</span><br><span class="line">right_bottom = (left_top[0] + w, left_top[1] + h)</span><br><span class="line">cv2.rectangle(image, left_top, right_bottom, (0, 0, 255))</span><br><span class="line">cv2.imshow(&#x27;image1&#x27;, image)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure>
<h3 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h3><p>霍夫变换是一种从图像中检测几何形状（如直线、圆等）的技术。对于直线检测，霍夫变换将图像空间中的点转换到参数空间（霍夫空间），通过在参数空间中寻找交点来确定直线。</p>
<blockquote>
<p><strong>霍夫变换的步骤</strong></p>
<ol>
<li><strong>边缘检测</strong>：</li>
</ol>
<ul>
<li>首先对图像进行边缘检测（如使用 Canny 边缘检测），得到二值边缘图像。</li>
</ul>
<ol start="2">
<li><strong>参数空间映射</strong>：</li>
</ol>
<ul>
<li>将图像空间中的边缘点映射到参数空间。</li>
</ul>
<ol start="3">
<li><strong>累加器统计</strong>：</li>
</ol>
<ul>
<li>在参数空间中使用累加器统计交点。</li>
</ul>
<ol start="4">
<li><strong>峰值检测</strong>：</li>
</ol>
<ul>
<li>找到累加器中的峰值，这些峰值对应图像中的形状。</li>
</ul>
</blockquote>
<h4 id="霍夫直线cv2-HoughLinesP"><a href="#霍夫直线cv2-HoughLinesP" class="headerlink" title="霍夫直线cv2.HoughLinesP"></a>霍夫直线cv2.HoughLinesP</h4><p>cv2.HoughLinesP 是 OpenCV 中用于检测图像中线段（有限长度的直线）的函数。它基于 <strong>概率霍夫变换（Probabilistic Hough Transform）</strong>，是 cv2.HoughLines 的改进版本。相比于 cv2.HoughLines，cv2.HoughLinesP 直接返回线段的端点坐标，计算效率更高，适合检测有限长度的线段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines = cv2.HoughLinesP(image, rho, theta, threshold, minLineLength, maxLineGap)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">1. image:</span><br><span class="line"> 输入图像，必须是单通道的二值图像（如边缘检测的结果）。</span><br><span class="line"> 通常使用 cv2.Canny 等边缘检测算法处理后的图像。</span><br><span class="line">2. rho:</span><br><span class="line"> 霍夫空间中 ρ 的分辨率（以像素为单位）。</span><br><span class="line"> 例如，常用值rho = 1 表示霍夫空间的 ρ 以 1 像素为单位递增。</span><br><span class="line">3. theta:</span><br><span class="line"> 霍夫空间中 θ 的分辨率（以弧度为单位）。</span><br><span class="line"> 例如，常用值theta = np.pi/180 表示 θ 以 1 度为单位递增。</span><br><span class="line">4. threshold:</span><br><span class="line"> 累加器的阈值。</span><br><span class="line"> 只有得票数（交点数量）超过该阈值的线段才会被检测到。</span><br><span class="line"> 阈值越高，检测到的线段越少。</span><br><span class="line">5. minLineLength:</span><br><span class="line"> 线段的最小长度。小于此长度的线段会被忽略。</span><br><span class="line"> 如果图像中有很多短线段，可以增加该值以过滤掉较短的线段。</span><br><span class="line">6. maxLineGap:</span><br><span class="line"> 线段之间的最大允许间隔。如果希望将接近的线段合并为一条直线，可以增加该值。</span><br><span class="line"> 如果两条线段之间的间隔小于此值，它们会被合并为一条线段。</span><br><span class="line"> maxLineGap 只对 同一条直线上的线段 起作用。如果图像中的线段不在同一条直线上，maxLineGap 再大也不会将它们合并</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">• lines:</span><br><span class="line"> 返回检测到的线段的列表，每条线段用 (x1, y1, x2, y2) 表示。</span><br><span class="line"> (x1, y1) 和 (x2, y2) 是线段的两个端点坐标。</span><br></pre></td></tr></table></figure>



<h4 id="霍夫圆-cv2-HoughCircles"><a href="#霍夫圆-cv2-HoughCircles" class="headerlink" title="霍夫圆 cv2.HoughCircles"></a>霍夫圆 cv2.HoughCircles</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">circles = cv2.HoughCircles(image, method, dp, minDist, param1=None, param2=None, minRadius=None, maxRadius=None)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">-   image：输入图像，应该是一个灰度图像（单通道）。</span><br><span class="line">-   method：检测圆形的方法。目前 OpenCV 只实现了 cv2.HOUGH_GRADIENT，它是基于图像梯度的方法。</span><br><span class="line">-   dp：累加器分辨率的倒数。例如，对于 dp=1.5，累加器将比图像小 1.5 倍。它决定了检测到的圆形的精度。</span><br><span class="line">-   minDist：检测到的圆之间的最小距离。如果两个圆之间的距离小于这个值，那么较小的圆将被忽略。</span><br><span class="line">-   param1：Canny 边缘检测器的高阈值（低阈值是高阈值的一半）。这是一个很重要的参数，因为它决定了边缘检测的准确性，进而影响圆形检测的结果。</span><br><span class="line">-   param2：累加器阈值。这个值越小，能够检测到的圆形就越多。它表示在累加器中累积的圆形候选点的数量阈值，只有累积点数超过这个阈值的圆形才会被返回。</span><br><span class="line">-   minRadius：圆形半径的最小值。</span><br><span class="line">-   maxRadius：圆形半径的最大值。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">-   circles：检测到的圆形的参数。如果未检测到圆形，则返回 None。否则，它返回一个三维数组，其中每一行表示一个检测到的圆形的参数：(x, y, radius)，其中 (x, y) 是圆形的中心坐标，radius 是圆形的半径。</span><br></pre></td></tr></table></figure>
<h3 id="图像亮度变换"><a href="#图像亮度变换" class="headerlink" title="图像亮度变换"></a>图像亮度变换</h3><p>np.clip 是 NumPy 库中的一个函数，用于将数组中的元素限制在指定的范围内。它会将数组中小于下限的值替换为下限，大于上限的值替换为上限，而介于两者之间的值保持不变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.clip(array, min, max, out=None)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">参数说明：</span><br><span class="line">1. array:</span><br><span class="line"> 输入的数组（可以是 NumPy 数组或类似数组的对象）。</span><br><span class="line">2. min:</span><br><span class="line"> 下限值。所有小于 min 的元素会被替换为 min。</span><br><span class="line"> 如果不需要下限，可以设置为 None。</span><br><span class="line">3. max:</span><br><span class="line"> 上限值。所有大于 max 的元素会被替换为 max。</span><br><span class="line"> 如果不需要上限，可以设置为 None。</span><br><span class="line">4. out (可选):</span><br><span class="line"> 用于存储结果的输出数组。如果不提供，会返回一个新的数组。</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">• 返回一个裁剪后的数组，元素值被限制在 [min, max] 范围内。</span><br></pre></td></tr></table></figure>
<h3 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h3><p>特征检测是计算机视觉中的一种技术，用于从图像或视频中提取显著且具有代表性的信息，这些信息通常用于后续的任务，如目标识别、图像匹配和运动跟踪。</p>
<h4 id="角点检测"><a href="#角点检测" class="headerlink" title="角点检测"></a>角点检测</h4><p>角点是图像中亮度变化剧烈或各个方向上梯度变化明显的点。与边缘不同，角点在多个方向上都有明显的梯度变化。<br>角点检测是计算机视觉中的一种技术，用于识别图像中具有显著变化的点，通常位于两条或多条边缘的交汇处。这些点被称为“角点”，它们在图像中具有独特的局部特征，适合用于图像匹配、目标识别和运动跟踪等任务。</p>
<h5 id="Harris角点检测"><a href="#Harris角点检测" class="headerlink" title="Harris角点检测"></a>Harris角点检测</h5><p>cv2.cornerHarris 是 OpenCV 库中用于实现 <strong>Harris****角点检测</strong> 的函数。Harris角点检测是一种经典的角点检测算法，用于识别图像中的角点（即两条边缘交汇的点）。这些角点通常具有较高的图像梯度变化，适合用于图像匹配、目标跟踪等任务。</p>
<h5 id="Shi-Tomasi角点检测"><a href="#Shi-Tomasi角点检测" class="headerlink" title="Shi-Tomasi角点检测"></a>Shi-Tomasi角点检测</h5><p>Shi-Tomasi角点检测是Harris角点检测的改进版本，在Harris算法的基础上进行了优化，可以不用设置k值，能够更准确地检测角点，尤其是在需要高质量角点的场景中（如目标跟踪、图像匹配等）。Shi-Tomasi角点检测的核心思想是通过最小特征值来判断角点。</p>
<h4 id="SIFT关键点检测"><a href="#SIFT关键点检测" class="headerlink" title="SIFT关键点检测"></a>SIFT关键点检测</h4><p>SIFT（Scale-Invariant Feature Transform，尺度不变特征变换）是一种经典的图像特征检测和描述算法，SIFT算法能够在不同尺度、旋转和光照条件下检测图像中的关键点，并生成具有高区分度的特征描述符。由于其鲁棒性和准确性，SIFT被广泛应用于图像匹配、目标识别、3D重建等领域。</p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="羽化边缘"><a href="#羽化边缘" class="headerlink" title="羽化边缘"></a>羽化边缘</h3><blockquote>
<ol>
<li>建立边缘模糊遮罩图片</li>
<li>根据遮罩黑白比例，合成主角与背景</li>
</ol>
</blockquote>
<p>使用 np.zeros 建立黑色画布后，在画布中心加入白色的圆形，接着进行高斯模糊，就完成一张边缘模糊的遮罩图片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">mask = np.zeros((300,300,3), dtype=&#x27;uint8&#x27;)      # 建立 300x300 的黑色畫布</span><br><span class="line">cv2.circle(mask,(150,150),100,(255,255,255),-1)  # 在畫布上中心點加入一個半徑 100 的白色圆形</span><br><span class="line">mask = cv2.GaussianBlur(mask, (35, 35), 0)       # 進行高斯模糊</span><br><span class="line"></span><br><span class="line">cv2.imshow(&#x27;oxxostudio&#x27;, mask)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="https://free.picui.cn/free/2025/08/31/68b42a996b462.png" alt="输入图片说明"></p>
<p>因为 OpenCV 的遮罩方法（参考 “影像遮罩”）所产生的遮罩 “不具有半透明” 的功能，因此如果要实现边缘渐层半透明的边缘羽化效果，必须根据黑色白色的比例进行主角与背景的混合。下面的代码执行后，会读取一张和遮罩同样尺寸的图片，以及生成同尺寸的一张白色背景，根据遮罩的黑白比例，将白色区域套用到图片，将黑色区域套用到背景，就能产生边缘羽化的图片效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">mask = np.zeros((300,300,3), dtype=&#x27;uint8&#x27;)</span><br><span class="line">cv2.circle(mask,(150,150),100,(255,255,255),-1)</span><br><span class="line">mask = cv2.GaussianBlur(mask, (35, 35), 0)</span><br><span class="line">mask = mask / 255                          # 除以 255，計算每個像素的黑白色彩在 255 中所佔的比例</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&#x27;mona.jpg&#x27;)               # 開啟圖片</span><br><span class="line">bg = np.zeros((300,300,3), dtype=&#x27;uint8&#x27;)  # 產生一張黑色背景</span><br><span class="line">bg = 255 - bg                              # 轉換成白色背景</span><br><span class="line">img = img / 255                            # 除以 255，計算每個像素的色彩在 255 中所佔的比例</span><br><span class="line">bg = bg / 255                              # 除以 255，計算每個像素的色彩在 255 中所佔的比例</span><br><span class="line"></span><br><span class="line">out  = bg * (1 - mask) + img * mask        # 根據比例混合</span><br><span class="line">out = (out * 255).astype(&#x27;uint8&#x27;)          # 乘以 255 之後轉換成整數</span><br><span class="line"></span><br><span class="line">cv2.imshow(&#x27;oxxostudio&#x27;,out)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p><img src="https://free.picui.cn/free/2025/08/31/68b42b645cb12.png" alt="输入图片说明"></p>
<p>来自<a target="_blank" rel="noopener" href="https://steam.oxxostudio.tw/category/python/ai/opencv-feather-edge.html">邊緣羽化效果 ( 邊緣模糊化 ) - OpenCV 教學 ( Python ) | STEAM 教育學習網</a></p>
<h3 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h3><blockquote>
<ol>
<li><p>从原始图片截取处要添加水印的位置roi</p>
</li>
<li><p>掩膜制作，让显示logo的位置为黑色0，其余地方为白色1</p>
</li>
<li><p>让roi和掩膜进行与操作得到img_tmp，logo的位置为黑色0</p>
</li>
<li><p>让img_tmp和logo进行加操作得到img_dst</p>
</li>
<li><p>将img_dst重新放回原始图片对应的位置</p>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 导入OpenCV的库</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"># 1. 读取原始图像和模板图</span><br><span class="line">image_np = cv2.imread(&#x27;./img/lena.png&#x27;)</span><br><span class="line">logo = cv2.imread(&#x27;./img/logo.png&#x27;)</span><br><span class="line">logo = cv2.resize(logo, (80, 120))</span><br><span class="line"># cv2.imshow(&#x27;image_np&#x27;, image_np)</span><br><span class="line"># 获取logo图的大小</span><br><span class="line">rows, cols = logo.shape[:2]</span><br><span class="line"># 截取原始图像的ROI区域</span><br><span class="line">roi = image_np[100:100+rows, 100:100+cols]</span><br><span class="line">cv2.imshow(&#x27;roi1&#x27;, roi)</span><br><span class="line"># 2. 对logo进行灰度化和二值化，制作成一张掩膜</span><br><span class="line">logo_gray = cv2.cvtColor(logo, cv2.COLOR_BGR2GRAY)</span><br><span class="line">ret, mask = cv2.threshold(logo_gray, 127, 255, cv2.THRESH_BINARY_INV)</span><br><span class="line"># 3. 进行与运算</span><br><span class="line">image_and = cv2.bitwise_and(roi, roi, mask=mask)</span><br><span class="line"># 4. 图像融合</span><br><span class="line">dst = cv2.add(image_and, logo)</span><br><span class="line"># 5. 将融合后的图像重新赋值到原始图像中</span><br><span class="line">image_np[100:100+rows, 100:100+cols] = dst</span><br><span class="line"># 6. 显示结果</span><br><span class="line">cv2.imshow(&#x27;logo&#x27;, logo)</span><br><span class="line">cv2.imshow(&#x27;roi2&#x27;, roi)</span><br><span class="line">cv2.imshow(&#x27;mask&#x27;, mask)</span><br><span class="line">cv2.imshow(&#x27;image_and&#x27;, image_and)</span><br><span class="line">cv2.imshow(&#x27;image_np1&#x27;, image_np)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://free.picui.cn/free/2025/08/31/68b424d9af3a3.png" alt="输入图片说明"></p>
<h3 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h3><blockquote>
<p>在浏览图片时，如果将小张的图片不断放大，就会看见图片的像素变大，成为一格格的马赛克。运用同样的原理，只要对图片使用 “两次 resize()” 的方式，就能快速实现马赛克的效果。</p>
</blockquote>
<p>下面的程序一开始运用 img.shape 获取图片尺寸，接着使用 cv2.resize () 方法（interpolation&#x3D;cv2.INTER_LINEAR）进行缩小，接着再度使用 cv2.resize () 方法搭配（interpolation&#x3D;cv2.INTER_NEAREST）进行放大，就会出现马赛克效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">img = cv2.imread(&#x27;mona.jpg&#x27;)</span><br><span class="line">size = img.shape         # 取得原始圖片的資訊</span><br><span class="line">level = 15               # 縮小比例 ( 可當作馬賽克的等級 )</span><br><span class="line">h = int(size[0]/level)   # 按照比例縮小後的高度 ( 使用 int 去除小數點 )</span><br><span class="line">w = int(size[1]/level)   # 按照比例縮小後的寬度 ( 使用 int 去除小數點 )</span><br><span class="line">mosaic = cv2.resize(img, (w,h), interpolation=cv2.INTER_LINEAR)   # 根據縮小尺寸縮小</span><br><span class="line">mosaic = cv2.resize(mosaic, (size[1],size[0]), interpolation=cv2.INTER_NEAREST) # 放大到原本的大小</span><br><span class="line">cv2.imshow(&#x27;oxxostudio&#x27;, mosaic)</span><br><span class="line">cv2.waitKey(0)           # 按下任意鍵停止</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      </div>
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>李猪兰
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lizhulan.github.io/2025/08/31/OpenCV/" title="OpenCV">https://lizhulan.github.io/2025/08/31/OpenCV/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>




      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/19/Python%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" rel="prev" title="Python代码规范">
      <i class="fa fa-chevron-left"></i> Python代码规范
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OpenCV"><span class="nav-number">1.</span> <span class="nav-text">OpenCV</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8API"><span class="nav-number">1.1.</span> <span class="nav-text">常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.1.</span> <span class="nav-text">基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%81%B0%E5%BA%A6%E5%8C%96"><span class="nav-number">1.1.2.</span> <span class="nav-text">灰度化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="nav-number">1.1.3.</span> <span class="nav-text">二值化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cv2-threshold%E2%80%94%E5%85%A8%E5%B1%80%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">cv2.threshold—全局二值化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E8%87%AA%E9%80%82%E5%BA%94%E4%BA%8C%E5%80%BC%E5%8C%96%E2%80%94%E5%B1%80%E9%83%A8%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">图像自适应二值化—局部二值化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86"><span class="nav-number">1.1.4.</span> <span class="nav-text">视频处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">读取摄像头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E8%A7%86%E9%A2%91"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">读取视频</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%84%E5%83%8F%E5%A4%B4%E5%BD%95%E8%A7%86%E9%A2%91"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">摄像头录视频</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%9B%BE"><span class="nav-number">1.1.5.</span> <span class="nav-text">绘图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">绘制直线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">绘制文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">绘制矩形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%9C%86%E5%BD%A2"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">绘制圆形</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%BD%A2%E6%80%81%E5%AD%A6%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.6.</span> <span class="nav-text">图像形态学变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B7%E7%A7%AF%E6%A0%B8"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">卷积核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%85%90%E8%9A%80"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">腐蚀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%86%A8%E8%83%80"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">膨胀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">开运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.6.5.</span> <span class="nav-text">闭运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%A2%E6%80%81%E5%AD%A6%E6%A2%AF%E5%BA%A6"><span class="nav-number">1.1.6.6.</span> <span class="nav-text">形态学梯度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E5%B8%BD%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.6.7.</span> <span class="nav-text">顶帽运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%91%E5%B8%BD%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.6.8.</span> <span class="nav-text">黑帽运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.7.</span> <span class="nav-text">图像运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0add-a-b"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">加add(a,b)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%8Fsubtract-a-b"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">减subtract(a,b)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E4%B9%98%E6%B3%95multiply-a-b-%E5%8F%98%E4%BA%AE%E6%9B%B4%E5%BF%AB"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">图像的乘法multiply(a, b)变亮更快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E9%99%A4%E6%B3%95divide-a-b-%E5%8F%98%E6%9A%97%E6%9B%B4%E5%BF%AB"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">图像的除法divide(a, b)变暗更快</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E6%BA%B6%E5%90%88addWeighted-A-alpha-B-beta-gamma"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">图像的溶合addWeighted(A, alpha, B, beta, gamma)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97-%E9%9D%9E%E6%93%8D%E4%BD%9Cbitwise-not-img"><span class="nav-number">1.1.7.6.</span> <span class="nav-text">图像的位运算-非操作bitwise_not(img)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97-%E4%B8%8E%E6%93%8D%E4%BD%9Cbitwise-and-img1-img2"><span class="nav-number">1.1.7.7.</span> <span class="nav-text">图像的位运算-与操作bitwise_and(img1, img2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97-%E6%88%96%E8%BF%90%E7%AE%97%E3%80%81%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.7.8.</span> <span class="nav-text">图像的位运算-或运算、异或运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%87%A0%E4%BD%95%E5%AD%A6%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.8.</span> <span class="nav-text">图像几何学变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%A9%E6%94%BEcv2-resize"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">缩放cv2.resize( )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BF%BB%E8%BD%ACcv2-flip"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">翻转cv2.flip( )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%8B%E8%BD%ACcv2-rotate"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">旋转cv2.rotate( )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E7%A7%BBcv2-warpAffine"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">平移cv2.warpAffine( )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5getRotationMatrix2D"><span class="nav-number">1.1.8.5.</span> <span class="nav-text">变换矩阵getRotationMatrix2D( )</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2-warpaffine"><span class="nav-number">1.1.8.6.</span> <span class="nav-text">仿射变换 warpaffine( )</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.9.</span> <span class="nav-text">插值方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E5%A1%AB%E5%85%85"><span class="nav-number">1.1.10.</span> <span class="nav-text">边界填充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E5%A4%8D%E5%88%B6%EF%BC%88cv2-BORDER-REPLICATE%EF%BC%89"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">边界复制（cv2.BORDER_REPLICATE）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E5%8F%8D%E5%B0%84-cv2-BORDER-REFLECT"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">边界反射(cv2.BORDER_REFLECT)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E5%8F%8D%E5%B0%84101-cv2-BORDER-REFLECT-101"><span class="nav-number">1.1.10.3.</span> <span class="nav-text">边界反射101(cv2.BORDER_REFLECT_101)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%95%B0%E5%A1%AB%E5%85%85%EF%BC%88cv2-BORDER-CONSTANT%EF%BC%89"><span class="nav-number">1.1.10.4.</span> <span class="nav-text">常数填充（cv2.BORDER_CONSTANT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E5%8C%85%E8%A3%85%EF%BC%88cv2-BORDER-WRAP%EF%BC%89"><span class="nav-number">1.1.10.5.</span> <span class="nav-text">外包装（cv2.BORDER_WRAP）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.11.</span> <span class="nav-text">透视变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5getPerspectiveTransform"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">透视变换矩阵getPerspectiveTransform</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2warpPerspective"><span class="nav-number">1.1.11.2.</span> <span class="nav-text">透视变换warpPerspective</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%A4%E6%B3%A2"><span class="nav-number">1.1.12.</span> <span class="nav-text">滤波</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">低通滤波</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E5%8D%B7%E7%A7%AFfilter2D"><span class="nav-number">1.1.12.1.1.</span> <span class="nav-text">二维卷积filter2D</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2cv2-blur"><span class="nav-number">1.1.12.1.2.</span> <span class="nav-text">均值滤波cv2.blur</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%A1%86%E6%BB%A4%E6%B3%A2-cv2-boxFilter"><span class="nav-number">1.1.12.1.3.</span> <span class="nav-text">方框滤波 cv2.boxFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2-cv2-GaussianBlur"><span class="nav-number">1.1.12.1.4.</span> <span class="nav-text">高斯滤波 cv2.GaussianBlur</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2-cv2-medianBlur"><span class="nav-number">1.1.12.1.5.</span> <span class="nav-text">中值滤波 cv2.medianBlur</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2-cv2-bilateralFilter"><span class="nav-number">1.1.12.1.6.</span> <span class="nav-text">双边滤波 cv2.bilateralFilter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2"><span class="nav-number">1.1.12.2.</span> <span class="nav-text">高通滤波</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Sobel%E7%AE%97%E5%AD%90"><span class="nav-number">1.1.12.2.1.</span> <span class="nav-text">Sobel算子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Laplacian%E7%AE%97%E5%AD%90"><span class="nav-number">1.1.12.2.2.</span> <span class="nav-text">Laplacian算子</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A4%E6%B3%A2FAQ"><span class="nav-number">1.1.12.3.</span> <span class="nav-text">滤波FAQ</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Canny%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.13.</span> <span class="nav-text">Canny边缘检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E5%BB%93"><span class="nav-number">1.1.13.1.</span> <span class="nav-text">轮廓</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E8%BD%AE%E5%BB%93cv2-findContours"><span class="nav-number">1.1.13.1.1.</span> <span class="nav-text">寻找轮廓cv2.findContours()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E8%BD%AE%E5%BB%93cv2-drawContours"><span class="nav-number">1.1.13.1.2.</span> <span class="nav-text">绘制轮廓cv2.drawContours</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%B8%E5%8C%85"><span class="nav-number">1.1.13.2.</span> <span class="nav-text">凸包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%B8%E5%8C%85%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8Bcv2-convexHull"><span class="nav-number">1.1.13.2.1.</span> <span class="nav-text">凸包特征检测cv2.convexHull</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%87%B8%E5%8C%85%E5%A4%9A%E8%BE%B9%E5%BD%A2cv2-polylines"><span class="nav-number">1.1.13.2.2.</span> <span class="nav-text">绘制凸包多边形cv2.polylines</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B-%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2"><span class="nav-number">1.1.13.3.</span> <span class="nav-text">轮廓特征检测-外接矩形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B-%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2"><span class="nav-number">1.1.13.4.</span> <span class="nav-text">轮廓特征检测-最小外接矩形</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2cv2-minAreaRect"><span class="nav-number">1.1.13.4.1.</span> <span class="nav-text">获取最小外接矩形cv2.minAreaRect</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%97%8B%E8%BD%AC%E7%9F%A9%E5%BD%A2%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%82%B9%E5%9D%90%E6%A0%87cv2-boxPoints"><span class="nav-number">1.1.13.4.2.</span> <span class="nav-text">获取旋转矩形的四个点坐标cv2.boxPoints</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AE%E5%BB%93%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B-%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E5%9C%86cv2-minEnclosingCircle"><span class="nav-number">1.1.13.5.</span> <span class="nav-text">轮廓特征检测-最小外接圆cv2.minEnclosingCircle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D"><span class="nav-number">1.1.14.</span> <span class="nav-text">模板匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.15.</span> <span class="nav-text">霍夫变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BFcv2-HoughLinesP"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">霍夫直线cv2.HoughLinesP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%8D%E5%A4%AB%E5%9C%86-cv2-HoughCircles"><span class="nav-number">1.1.15.2.</span> <span class="nav-text">霍夫圆 cv2.HoughCircles</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E4%BA%AE%E5%BA%A6%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.16.</span> <span class="nav-text">图像亮度变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.17.</span> <span class="nav-text">特征检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.17.1.</span> <span class="nav-text">角点检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.17.1.1.</span> <span class="nav-text">Harris角点检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Shi-Tomasi%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.17.1.2.</span> <span class="nav-text">Shi-Tomasi角点检测</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SIFT%E5%85%B3%E9%94%AE%E7%82%B9%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.17.2.</span> <span class="nav-text">SIFT关键点检测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">常用操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BE%BD%E5%8C%96%E8%BE%B9%E7%BC%98"><span class="nav-number">1.2.1.</span> <span class="nav-text">羽化边缘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">添加水印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%AC%E8%B5%9B%E5%85%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">马赛克</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李猪兰"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">李猪兰</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lizhulan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lizhulan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lizhulan@example.com" title="E-Mail → mailto:lizhulan@example.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/docs/" title="Docs → &#x2F;docs&#x2F;"><i class="fa fa-book fa-fw"></i>Docs</a>
      </span>
      <span class="links-of-author-item">
        <a href="/plugins/" title="Plugins → &#x2F;plugins&#x2F;"><i class="fa fa-plug fa-fw"></i>Plugins</a>
      </span>
      <span class="links-of-author-item">
        <a href="/archives/" title="Archives → &#x2F;archives&#x2F;"><i class="fa fa-archive fa-fw"></i>Archives</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李猪兰</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">81k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:14</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共42.6k字</span>
</div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script color='102,126,234' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script size="300" alpha="0.3" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
